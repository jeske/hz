<HTML>
<HEAD>
<TITLE>Lua: reference manual 4.0</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<HR>
<H1>
<IMG SRC="../images/logo.gif" ALT="Lua" ALIGN="bottom">
Reference Manual of the Programming Language
<A HREF="../home.html">Lua</A>
4.0
</H1>

<!--  $Id: manual.html,v 1.1 2000/07/20 10:16:44 jeske Exp $ -->
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="1."></A>
<H1>1 - Introduction</H1>
<P>
Lua is an extension programming language designed to support
general procedural programming with data description
facilities.
Lua is intended to be used as a light-weight, but powerful,
configuration language for any program that needs one.
<P>
Lua is implemented as a library, written in C.
Being an extension language, Lua has no notion of a ``main'' program:
it only works <EM>embedded</EM> in a host client,
called the <EM>embedding</EM> program.
This host program can invoke functions to execute a piece of
code in Lua, can write and read Lua variables,
and can register C functions to be called by Lua code.
Through the use of C functions, Lua can be augmented to cope with
a wide range of different domains,
thus creating customized programming languages sharing a syntactical framework.
<P>
Lua is free-distribution software,
and provided as usual with no guarantees,
as stated in the copyright notice.
The implementation described in this manual is available
at the following URL's:
<PRE>
   <A HREF="http://www.tecgraf.puc-rio.br/lua/">http://www.tecgraf.puc-rio.br/lua/</A>
   <A HREF="ftp://ftp.tecgraf.puc-rio.br/pub/lua/lua.tar.gz">ftp://ftp.tecgraf.puc-rio.br/pub/lua/lua.tar.gz</A>
</PRE>
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="2."></A>
<H1>2 - Environment and Chunks</H1>
<P>
All statements in Lua are executed in a <A NAME="global environment"><EM>global environment</EM></A>.
This environment, which keeps all global variables,
is initialized with a call from the embedding program to
<CODE>lua_newstate</CODE> and
persists until a call to <CODE>lua_close</CODE>,
or the end of the embedding program.
Optionally, a user can create multiple independent global
environments (see Section&nbsp;<A HREF="#mangstate">5.1</A>).
<P>
The global environment can be manipulated by Lua code or
by the embedding program,
which can read and write global variables
using API functions from the library that implements Lua.
<P>
<A NAME="Global variables">Global variables</A> do not need declaration.
Any variable is assumed to be global unless explicitly declared local
(see Section&nbsp;<A HREF="#localvar">4.5.6</A>).
Before the first assignment, the value of a global variable is <B>nil</B>;
this default can be changed (see Section&nbsp;<A HREF="#tag-method">4.8</A>).
<P>
The unit of execution of Lua is called a <A NAME="chunk"><EM>chunk</EM></A>.
A chunk is simply a sequence of statements:
<PRE>
chunk ::= {stat} [ret]
</PRE>
Statements are described in Section&nbsp;<A HREF="#stats">4.5</A>.
(As usual, {<EM>a</EM>} means 0 or more <EM>a</EM>'s,
[<EM>a</EM>] means an optional <EM>a</EM> and ('<EM>a</EM>)+ means
one or more <EM>a</EM>'s.)
<P>
A chunk may be in a file or in a string inside the host program.
A chunk may optionally end with a <CODE>return</CODE> statement (see Section&nbsp;<A HREF="#return">4.5.3</A>).
When a chunk is executed, first all its code is pre-compiled,
then the statements are executed in sequential order.
All modifications a chunk effects on the global environment persist
after the chunk end.
<P>
Chunks may also be pre-compiled into binary form;
see program <A NAME="luac"><TT><A HREF="luac.html">luac</A></TT></A> for details.
Text files with chunks and their binary pre-compiled forms
are interchangeable.
Lua automatically detects the file type and acts accordingly.
<A NAME="pre-compilation"></A>
<P>
<A NAME="TypesSec"></A>
<!-- ====================================================================== -->
<HR>
<A NAME="3."></A>
<H1>3 - Types and Tags</H1> 
<P>
Lua is a dynamically typed language.
Variables do not have types; only values do.
Therefore, there are no type definitions in the language.
All values carry their own type.
Besides a type, all values also have a <A NAME="tag">tag</A>.
<P>
There are six <A NAME="basic types">basic types</A> in Lua: <A NAME="nil"><EM>nil</EM></A>, <A NAME="number"><EM>number</EM></A>,
<A NAME="string"><EM>string</EM></A>, <A NAME="function"><EM>function</EM></A>, <A NAME="userdata"><EM>userdata</EM></A>, and <A NAME="table"><EM>table</EM></A>.
<EM>Nil</EM> is the type of the value <B>nil</B>,
whose main property is to be different from any other value.
<EM>Number</EM> represents real (double-precision floating-point) numbers,
while <EM>string</EM> has the usual meaning.
Lua is <A NAME="eight-bit clean">eight-bit clean</A>,
and so strings may contain any 8-bit character,
<EM>including</EM> embedded zeros (<CODE>'\0'</CODE>).
The <CODE>type</CODE> function returns a string describing the type
of a given value (see Section&nbsp;<A HREF="#pdf-type">6.1</A>).
<P>
Functions are considered first-class values in Lua.
This means that functions can be stored in variables,
passed as arguments to other functions, and returned as results.
Lua can call (and manipulate) functions written in Lua and
functions written in C.
They can be distinguished by their tags:
all Lua functions have the same tag,
and all C functions have the same tag,
which is different from the tag of Lua functions.
The <CODE>tag</CODE> function returns the tag
of a given value (see Section&nbsp;<A HREF="#pdf-tag">6.1</A>).
<P>
The type <EM>userdata</EM> is provided to allow
arbitrary <A NAME="C pointers">C pointers</A> to be stored in Lua variables.
It corresponds to a <CODE>void*</CODE> and has no pre-defined operations in Lua,
besides assignment and equality test.
However, by using <EM>tag methods</EM>,
the programmer can define operations for <EM>userdata</EM> values
(see Section&nbsp;<A HREF="#tag-method">4.8</A>).
<P>
The type <EM>table</EM> implements <A NAME="associative arrays">associative arrays</A>,
that is, <A NAME="arrays">arrays</A> that can be indexed not only with numbers,
but with any value (except <B>nil</B>).
Therefore, this type may be used not only to represent ordinary arrays,
but also symbol tables, sets, records, etc.
Tables are the main data structuring mechanism in Lua.
To represent <A NAME="records">records</A>, Lua uses the field name as an index.
The language supports this representation by
providing <CODE>a.name</CODE> as syntactic sugar for <CODE>a["name"]</CODE>.
Tables may also carry methods:
Because functions are first class values,
table fields may contain functions.
The form <CODE>t:f(x)</CODE> is syntactic sugar for <CODE>t.f(t,x)</CODE>,
which calls the method <CODE>f</CODE> from the table <CODE>t</CODE> passing
itself as the first parameter (see Section&nbsp;<A HREF="#func-def">4.6.9</A>).
<P>
Note that tables are <EM>objects</EM>, and not values.
Variables cannot contain tables, only <EM>references</EM> to them.
Assignment, parameter passing, and returns always manipulate references
to tables, and do not imply any kind of copy.
Moreover, tables must be explicitly created before used
(see Section&nbsp;<A HREF="#tableconstructor">4.6.7</A>).
<P>
Tags are mainly used to select <EM>tag methods</EM> when
some events occur.
Tag methods are the main mechanism for extending the
semantics of Lua (see Section&nbsp;<A HREF="#tag-method">4.8</A>).
Each of the types <EM>nil</EM>, <EM>number</EM> and <EM>string</EM> has a different tag.
All values of each of these types have this same pre-defined tag.
Values of type <EM>function</EM> can have two different tags,
depending on whether they are Lua functions or C functions.
Finally,
values of type <EM>userdata</EM> and <EM>table</EM> have
variable tags, assigned by the program (see Section&nbsp;<A HREF="#tag-method">4.8</A>).
Tags are created with the function <CODE>newtag</CODE>,
and the function <CODE>tag</CODE> returns the tag of a given value.
To change the tag of a given table,
there is the function <CODE>settag</CODE> (see Section&nbsp;<A HREF="#pdf-newtag">6.1</A>).
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="4."></A>
<H1>4 - The Language</H1>
<P>
This section describes the lexis, the syntax and the semantics of Lua.
<P>
<P>
<A NAME="lexical"></A>
<A NAME="4.1"></A>
<H2>4.1 - Lexical Conventions</H2> 
<P>
<A NAME="Identifiers">Identifiers</A> in Lua can be any string of letters,
digits, and underscores,
not beginning with a digit.
The definition of letter depends on the current locale:
Any character considered alphabetic by the current locale
can be used in an identifier.
The following words are reserved, and cannot be used as identifiers:
<A NAME="reserved words"></A>
<PRE>
      and       break     do        else
      elseif    end       for       function
      if        local     nil       not
      or        repeat    return    then
      until     while
</PRE>
Lua is a case-sensitive language:
<TT>and</TT> is a reserved word, but <TT>And</TT> and <TT>\'and</TT>
(if the locale permits) are two other different identifiers.
As a convention, identifiers starting with underscore followed by
uppercase letters (such as <CODE>_INPUT</CODE>)
are reserved for internal variables.
<P>
The following strings denote other <A NAME="tokens">tokens</A>:
<PRE>
         ~=  &lt;=  &gt;=  &lt;   &gt;   ==  =   +   -   *   /   
         (   )   {   }   [   ]   ;   ,   .   ..  ...
</PRE>
<P>
<A NAME="Literal strings">Literal strings</A> can be delimited by matching single or double quotes,
and can contain the C-like escape sequences
<CODE>'\a'</CODE> (bell),
<CODE>'\b'</CODE> (backspace),
<CODE>'\f'</CODE> (form feed),
<CODE>'\n'</CODE> (newline),
<CODE>'\r'</CODE> (carriage return),
<CODE>'\t'</CODE> (horizontal tab),
<CODE>'\v'</CODE> (vertical tab),
<CODE>'\\'</CODE>, (backslash),
<CODE>'\"'</CODE>, (double quote),
<CODE>'\''</CODE> (single quote),
and <CODE>'\\n'</CODE> (that is, a backslash followed by a real newline,
which  results in a newline in the string).
A character in a string may also be specified by its numerical value,
through the escape sequence <CODE>'\ddd'</CODE>,
where <CODE>ddd</CODE> is a sequence of up to three <EM>decimal</EM> digits.
Strings in Lua may contain any 8-bit value, including embedded zeros.
<P>
Literal strings can also be delimited by matching <CODE>[[ ... ]]</CODE>.
Literals in this bracketed form may run for several lines,
may contain nested <CODE>[[ ... ]]</CODE> pairs,
and do not interpret escape sequences.
This form is specially convenient for
writing strings that contain program pieces or
other quoted strings.
As an example, in a system using ASCII,
the following three literals are equivalent:
<PRE>
1) "alo\n123\""
2) '\97lo\10\04923"'
3) [[alo
   123"]]
</PRE>
<P>
<P>
<A NAME="Comments">Comments</A> start anywhere outside a string with a
double hyphen (<CODE>--</CODE>) and run until the end of the line.
Moreover,
the first line of a chunk is skipped if it starts with <CODE>#</CODE>.
This facility allows the use of Lua as a script interpreter
in Unix systems (see Section&nbsp;<A HREF="#lua-sa">8</A>).
<P>
<A NAME="Numerical constants">Numerical constants</A> may be written with an optional decimal part,
and an optional decimal exponent.
Examples of valid numerical constants are
<PRE>
       3     3.0     3.1416  314.16e-2   0.31416E1
</PRE>
<P>
<A NAME="pre-processor"></A>
<A NAME="4.2"></A>
<H2>4.2 - The Pre-processor</H2> 
<P>
All lines that start with a <CODE>$</CODE> sign are handled by a pre-processor.
The <CODE>$</CODE> sign must be immediately
followed by one of the following directives:
<DL>
<DT><B><TT>debug</TT></B><DD> - turn on debugging facilities (see Section&nbsp;<A HREF="#pragma">4.9</A>).
<DT><B><TT>nodebug</TT></B><DD> - turn off debugging facilities (see Section&nbsp;<A HREF="#pragma">4.9</A>).
<DT><B><TT>if <EM>cond</TT></EM></B><DD> - starts a conditional part.
If <EM>cond</EM> is false, then this part is skipped by the lexical analyzer.
<DT><B><TT>ifnot <EM>cond</TT></EM></B><DD> - starts a conditional part.
If <EM>cond</EM> is true, then this part is skipped by the lexical analyzer.
<DT><B><TT>end</TT></B><DD> - ends a conditional part.
<DT><B><TT>else</TT></B><DD> - starts an ``else'' conditional part,
flipping the ``skip'' status.
<DT><B><TT>endinput</TT></B><DD> - ends the lexical parse of the file.
</DL>
<P>
Directives may be freely nested.
Particularly, a <CODE>$endinput</CODE> may occur inside a <CODE>$if</CODE>;
in that case, even the matching <CODE>$end</CODE> is not parsed.
<P>
A <EM>cond</EM> part may be
<DL>
<DT><B><TT>nil</TT></B><DD> - always false.
<DT><B><TT>1</TT></B><DD> - always true.
<DT><B><TT><EM>name</TT></EM></B><DD> - true if the value of the
global variable <EM>name</EM> is different from <B>nil</B>.
Note that <EM>name</EM> is evaluated <EM>before</EM> the chunk starts its execution.
Therefore, actions in a chunk do not affect its own conditional directives.
</DL>
<P>
<A NAME="coercion"></A>
<A NAME="4.3"></A>
<H2>4.3 - Coercion</H2> 
<P>
Lua provides some automatic conversions between values at run time.
Any arithmetic operation applied to a string tries to convert
that string to a number, following the usual rules.
Conversely, whenever a number is used when a string is expected,
that number is converted to a string, in a reasonable format.
For complete control on how numbers are converted to strings,
use the <CODE>format</CODE> function (see Section&nbsp;<A HREF="#format">6.2</A>).
<P>
<P>
<A NAME="adjust"></A>
<A NAME="4.4"></A>
<H2>4.4 - Adjustment</H2> 
<P>
Functions in Lua can return many values.
Because there are no type declarations,
when a function is called
the system does not know how many values a function will return,
or how many parameters it needs.
Therefore, sometimes, a list of values must be <EM>adjusted</EM>, at run time,
to a given length.
If there are more values than are needed,
then the excess values are thrown away.
If there are more needs than values,
then the list is extended with as many  <B>nil</B>'s as needed.
Adjustment occurs in multiple assignment (see Section&nbsp;<A HREF="#assignment">4.5.2</A>)
and function calls (see Section&nbsp;<A HREF="#functioncall">4.6.8</A>).
<P>
<P>
<A NAME="stats"></A>
<A NAME="4.5"></A>
<H2>4.5 - Statements</H2>
<P>
Lua supports an almost conventional set of <A NAME="statements">statements</A>,
similar to those in Pascal or C.
The conventional commands include
assignment, control structures and procedure calls.
Non-conventional commands include table constructors
(see Section&nbsp;<A HREF="#tableconstructor">4.6.7</A>),
and local variable declarations (see Section&nbsp;<A HREF="#localvar">4.5.6</A>).
<P>
<H3>4.5.1 - Blocks</H3>
A <A NAME="block">block</A> is a list of statements, which are executed sequentially.
A statement may be have an optional label,
and can be optionally followed by a semicolon:
<PRE>
block ::= [label] {stat sc}
sc ::= ['<B>;</B>']
label ::= '<B>|</B>' name '<B>|</B>'
</PRE>
For syntactic reasons, <B>return</B> and
<B>break</B> statements can only be written
as the last statement of a block.
<P>
A block may be explicitly delimited:
<PRE>
stat ::= <B>do</B> block <B>end</B>
</PRE>
This is useful to control the scope of local variables (see Section&nbsp;<A HREF="#localvar">4.5.6</A>),
and to add a <B>return</B> or a <B>break</B> statement in the middle
of another block:
<PRE>
  do return end        -- return is the last statement in this block
</PRE>
<P>
<A NAME="assignment"></A>
<H3>4.5.2 - <A NAME="Assignment</H3>">Assignment</H3></A> 
The language allows <A NAME="multiple assignment">multiple assignment</A>.
Therefore, the syntax for assignment
defines a list of variables on the left side,
and a list of expressions on the right side.
Both lists have their elements separated by commas:
<PRE>
stat ::= varlist1 '<B>=</B>' explist1
varlist1 ::= var {'<B>,</B>' var}
</PRE>
This statement first evaluates all values on the right side
and eventual indices on the left side,
and then makes the assignments.
Therefore, it can be used to exchange two values, as in
<PRE>
   x, y = y, x
</PRE>
The two lists may have different lengths.
Before the assignment, the list of values is <EM>adjusted</EM> to
the length of the list of variables (see Section&nbsp;<A HREF="#adjust">4.4</A>).
<P>
A single name can denote a global variable, a local variable,
or a formal parameter:
<PRE>
var ::= name
</PRE>
Square brackets are used to index a table:
<PRE>
var ::= simpleexp '<B>[</B>' exp1 '<B>]</B>'
</PRE>
The <EM>simpleexp</EM> should result in a table value,
from where the field indexed by the expression
value gets the assigned value.
<P>
The syntax <CODE>var.NAME</CODE> is just syntactic sugar for
<CODE>var["NAME"]</CODE>:
<PRE>
var ::= simpleexp '<B>.</B>' name
</PRE>
<P>
The meaning of assignments and evaluations of global variables and
indexed variables can be changed by tag methods (see Section&nbsp;<A HREF="#tag-method">4.8</A>).
Actually,
an assignment <CODE>x = val</CODE>, where <CODE>x</CODE> is a global variable,
is equivalent to a call <CODE>setglobal('x', val)</CODE>;
an assignment <CODE>t[i] = val</CODE> is equivalent to
<CODE>settable_event(t, i, val)</CODE>.
See Section&nbsp;<A HREF="#tag-method">4.8</A> for a complete description of these functions.
(Function <CODE>setglobal</CODE> is pre-defined in Lua.
Function <TT>settable_event</TT> is used only for explanatory purposes.)
<P>
<H3>4.5.3 - Control Structures</H3>
The <A NAME="condition expression">condition expression</A> of a control structure may return any value.
All values different from <B>nil</B> are considered true;
only <B>nil</B> is considered false.
<TT>if</TT>'s, <TT>while</TT>'s and <TT>repeat</TT>'s have the usual meaning.
<P>
<A NAME="while-do"></A><A NAME="repeat-until"></A><A NAME="if-then-else"></A>
<PRE>
stat ::= <B>while</B> exp1 <B>do</B> block <B>end</B> <BR>	| <B>repeat</B> block <B>until</B> exp1 <BR>	| <B>if</B> exp1 <B>then</B> block {<B>elseif</B> exp1 <B>then</B> block} [<B>else</B> block] <B>end</B>
</PRE>
<P>
<A NAME="return"></A>
A <B>return</B> is used to return values from a function or from a chunk.
<A NAME="return"></A>

Because they may return more than one value,
the syntax for a <A NAME="return statement">return statement</A> is
<PRE>
stat ::= <B>return</B> [explist1]
</PRE>
<P>
<A NAME="break"></A>
A <B>break</B> statement can be used to terminate the execution of a block,
skipping to the next instruction after the block.
<PRE>
stat ::= <B>break</B> [name]
</PRE>
A <B>break</B> without a label ends the inner enclosing loop
(while, repeat, or for).
A <B>break</B> with a label breaks the inner enclosing
statement with that label.
<P>
For syntactic reasons, <B>return</B> and <B>break</B>
statements can only be written as the last statement of a block.
<P>
<A NAME="for"></A>
<H3>4.5.4 - For Statement</H3> <A NAME="for"></A>
<P>
The <B>for</B> statement has the following syntax:
<PRE>
stat ::= <B>for</B> name '<B>=</B>' exp1 '<B>,</B>' exp1 ['<B>,</B>' exp1] <B>do</B> block <B>end</B>
</PRE>
A <B>for</B> statement like
<PRE>
for var=e1,e2,e3 do block end
</PRE>
is equivalent to the following code:
<PRE>
do
  local var, _limit, _step = tonumber(e1), tonumber(e2), tonumber(e3)
  if not (var and _limit and _step) then error() end
  while (_step&gt;0 and var&lt;=_limit) or (_step&lt;=0 and var&gt;=_limit) do
    block
    var = var+_step
  end
end
</PRE>
Notice the following:
<UL>
<LI><CODE>_limit</CODE> and <CODE>_step</CODE> are invisible variables.
<LI>The behavior is undefined if you assign to <CODE>var</CODE> inside
the block.
<LI>If the third expression (the step) is absent, it defaults to 1.
<LI>Both the limit and the step are evaluated only once,
before the loop starts.
<LI>The variable <CODE>var</CODE> is local to the statement;
you cannot use its value after the <B>for</B>.
<LI>You can use <B>break</B> to exit a <B>for</B>.
If you need the value of the index,
assign it to another variable before breaking.
</UL>
<P>
<A NAME="funcstat"></A>
<H3>4.5.5 - Function Calls as Statements</H3> 
Because of possible side-effects,
function calls can be executed as statements:
<PRE>
stat ::= functioncall
</PRE>
In this case, all returned values are thrown away.
Function calls are explained in Section&nbsp;<A HREF="#functioncall">4.6.8</A>.
<P>
<A NAME="localvar"></A>
<H3>4.5.6 - Local Declarations</H3> 
<A NAME="Local variables">Local variables</A> may be declared anywhere inside a block.
Their scope begins after the declaration and lasts until the
end of the block.
The declaration may include an initial assignment:
<PRE>
stat ::= <B>local</B> declist [init]
declist ::= name {'<B>,</B>' name}
init ::= '<B>=</B>' explist1
</PRE>
If present, an initial assignment has the same semantics
of a multiple assignment.
Otherwise, all variables are initialized with <B>nil</B>.
<P>
<P>
<A NAME="4.6"></A>
<H2>4.6 - Expressions</H2>
<P>
<H3>4.6.1 - <A NAME="Basic Expressions</H3>">Basic Expressions</H3></A>
The basic expressions in Lua are
<PRE>
exp ::= '<B>(</B>' exp '<B>)</B>'
exp ::= <B>nil</B>
exp ::= '<B>number</B>'
exp ::= '<B>literal</B>'
exp ::= function
exp ::= simpleexp
</PRE>
<PRE>
simpleexp ::= var
simpleexp ::= upvalue
simpleexp ::= functioncall
</PRE>
<P>
Numbers (numerical constants) and
string literals are explained in Section&nbsp;<A HREF="#lexical">4.1</A>;
variables are explained in Section&nbsp;<A HREF="#assignment">4.5.2</A>;
upvalues are explained in Section&nbsp;<A HREF="#upvalue">4.7</A>;
function definitions (<EM>function</EM>) are explained in Section&nbsp;<A HREF="#func-def">4.6.9</A>;
function calls are explained in Section&nbsp;<A HREF="#functioncall">4.6.8</A>.
<P>
An access to a global variable <CODE>x</CODE> is equivalent to a
call <CODE>getglobal('x')</CODE>;
an access to an indexed variable <CODE>t[i]</CODE> is equivalent to
a call <CODE>gettable_event(t, i)</CODE>.
See Section&nbsp;<A HREF="#tag-method">4.8</A> for a description of these functions.
(Function <CODE>getglobal</CODE> is pre-defined in Lua.
Function <TT>gettable_event</TT> is used only for explanatory purposes.)
<P>
The non-terminal <EM>exp1</EM> is used to indicate that the values
returned by an expression must be adjusted to one single value:
<PRE>
exp1 ::= exp
</PRE>
<P>
<H3>4.6.2 - Arithmetic Operators</H3>
Lua supports the usual <A NAME="arithmetic operators">arithmetic operators</A>:
the binary <CODE>+</CODE> (addition),
<CODE>-</CODE> (subtraction), <CODE>*</CODE> (multiplication),
<CODE>/</CODE> (division) and <CODE>^</CODE> (exponentiation),
and unary <CODE>-</CODE> (negation).
If the operands are numbers, or strings that can be converted to
numbers (according to the rules given in Section&nbsp;<A HREF="#coercion">4.3</A>),
then all operations except exponentiation have the usual meaning.
Otherwise, an appropriate tag method is called (see Section&nbsp;<A HREF="#tag-method">4.8</A>).
An exponentiation always calls a tag method.
The standard mathematical library redefines this method for numbers,
giving the expected meaning to <A NAME="exponentiation">exponentiation</A>
(see Section&nbsp;<A HREF="#mathlib">6.3</A>).
<P>
<H3>4.6.3 - Relational Operators</H3>
Lua provides the following <A NAME="relational operators">relational operators</A>:
<PRE>
       ==  ~=  &lt;   &gt;   &lt;=  &gt;=
</PRE>
All these return <B>nil</B> as false and a value different from <B>nil</B> as true.
<P>
Equality first compares the tags of its operands.
If they are different, then the result is <B>nil</B>.
Otherwise, their values are compared.
Numbers and strings are compared in the usual way.
Tables, userdata, and functions are compared by reference,
that is, two tables are considered equal only if they are the same table.
The operator <CODE>~=</CODE> is exactly the negation of equality (<CODE>==</CODE>).
<P>
The conversion rules of Section&nbsp;<A HREF="#coercion">4.3</A>
<EM>do not</EM> apply to equality comparisons.
Thus, <CODE>"0"==0</CODE> evaluates to false,
and <CODE>t[0]</CODE> and <CODE>t["0"]</CODE> denote different
entries in a table.
<P>
The order operators work as follows.
If both arguments are numbers, then they are compared as such.
Otherwise, if both arguments are strings,
then their values are compared using lexicographical order.
Otherwise, the <CODE>"lt"</CODE> tag method is called (see Section&nbsp;<A HREF="#tag-method">4.8</A>).
<P>
<H3>4.6.4 - Logical Operators</H3>
The <A NAME="logical operators">logical operators</A> are
<A NAME="and"></A><A NAME="or"></A><A NAME="not"></A>
<PRE>
             and   or   not
</PRE>
Like control structures, all logical operators
consider <B>nil</B> as false and anything else as true.
The operator <CODE>and</CODE> returns <B>nil</B> if its first argument is <B>nil</B>;
otherwise, it returns its second argument.
The operator <CODE>or</CODE> returns its first argument
if it is different from <B>nil</B>;
otherwise, it returns its second argument.
Both <CODE>and</CODE> and <CODE>or</CODE> use <A NAME="short-cut evaluation">short-cut evaluation</A>,
that is,
the second operand is evaluated only when necessary.
<P>
There are two useful Lua idioms with logical operators.
The first is <CODE>x = x or v</CODE>,
which is equivalent to
<PRE>
      if x == nil then x = v end
</PRE>
i.e., it sets <CODE>x</CODE> to a default value <CODE>v</CODE> when
<CODE>x</CODE> is not set.
The other is <CODE>x = a and b or c</CODE>,
which is equivalent to
<PRE>
      if a then x = b else x = c end
</PRE>
provided that <CODE>b</CODE> is not <B>nil</B>.
<P>
<H3>4.6.5 - Concatenation</H3>
The string <A NAME="concatenation">concatenation</A> operator in Lua is
denoted by ``<A NAME=".."><TT>..</TT></A>''.
If both operands are strings or numbers, they are converted to
strings according to the rules in Section&nbsp;<A HREF="#coercion">4.3</A>.
Otherwise, the ``concat'' tag method is called (see Section&nbsp;<A HREF="#tag-method">4.8</A>).
<P>
<H3>4.6.6 - Precedence</H3>
<A NAME="Operator precedence">Operator precedence</A> follows the table below,
from the lower to the higher priority:
<PRE>
             and   or
             &lt;   &gt;   &lt;=  &gt;=  ~=  ==
             ..
             +   -
             *   /
             not  - (unary)
             ^
</PRE>
All binary operators are left associative,
except for <CODE>^</CODE> (exponentiation),
which is right associative.
The pre-compiler may rearrange the order of evaluation of
associative operators (such as <CODE>..</CODE> or <CODE>+</CODE>),
as long as these optimizations do not change normal results.
However, they may change some results if you define non-associative
tag methods for these operators.
<P>
<A NAME="tableconstructor"></A>
<H3>4.6.7 - Table Constructors</H3> 
Table <A NAME="constructors">constructors</A> are expressions that create tables;
every time a constructor is evaluated, a new table is created.
Constructors can be used to create empty tables,
or to create a table and initialize some fields.
<P>
The general syntax for constructors is
<PRE>
tableconstructor ::= '<B>{</B>' fieldlist '<B>}</B>'
fieldlist ::= lfieldlist | ffieldlist | lfieldlist '<B>;</B>' ffieldlist | ffieldlist '<B>;</B>' lfieldlist
lfieldlist ::= [lfieldlist1]
ffieldlist ::= [ffieldlist1]
</PRE>
<P>
The form <EM>lfieldlist1</EM> is used to initialize lists:
<PRE>
lfieldlist1 ::= exp {'<B>,</B>' exp} ['<B>,</B>']
</PRE>
The expressions in the list are assigned to consecutive numerical indices,
starting with 1.
For example,
<PRE>
   a = {"v1", "v2", 34}
</PRE>
is equivalent to
<PRE>
  do
    local temp = {}
    temp[1] = "v1"
    temp[2] = "v2"
    temp[3] = 34
    a = temp
  end
</PRE>
<P>
The form <EM>ffieldlist1</EM> initializes other fields in a table:
<PRE>
ffieldlist1 ::= ffield {'<B>,</B>' ffield} ['<B>,</B>']
ffield ::= '<B>[</B>' exp '<B>]</B>' '<B>=</B>' exp | name '<B>=</B>' exp
</PRE>
For example,
<PRE>
   a = {[f(k)] = g(y), x = 1, y = 3, [0] = b+c}
</PRE>
is equivalent to
<PRE>
  do
    local temp = {}
    temp[f(k)] = g(y)
    temp.x = 1    -- or temp["x"] = 1
    temp.y = 3    -- or temp["y"] = 3
    temp[0] = b+c
    a = temp
  end
</PRE>
An expression like <CODE>{x = 1, y = 4}</CODE> is
in fact syntactic sugar for <CODE>{["x"] = 1, ["y"] = 4}</CODE>.
<P>
Both forms may have an optional trailing comma,
and can be used in the same constructor separated by
a semi-collon.
For example, all forms below are correct:
<PRE>
   x = {;}
   x = {'a', 'b',}
   x = {type='list'; 'a', 'b'}
   x = {f(0), f(1), f(2),; n=3,}
</PRE>
<P>
<A NAME="functioncall"></A>
<H3>4.6.8 - Function Calls</H3>  
A <A NAME="function call">function call</A> has the following syntax:
<PRE>
functioncall ::= simpleexp args
</PRE>
First, <EM>simpleexp</EM> is evaluated.
If its value has type <EM>function</EM>,
then this function is called,
with the given arguments.
Otherwise, the ``function'' tag method is called,
having as first parameter the value of <EM>simpleexp</EM>,
and then the original call arguments.
<P>
The form
<PRE>
functioncall ::= simpleexp '<B>:</B>' name args
</PRE>
can be used to call ``methods''.
A call <CODE>simpleexp:name(...)</CODE>
is syntactic sugar for
<PRE>
  simpleexp.name(simpleexp, ...)
</PRE>
except that <CODE>simpleexp</CODE> is evaluated only once.
<P>
Arguments have the following syntax:
<PRE>
args ::= '<B>(</B>' [explist1] '<B>)</B>'
args ::= tableconstructor
args ::= '<B>literal</B>'
explist1 ::= {exp1 '<B>,</B>'} exp
</PRE>
All argument expressions are evaluated before the call.
A call of the form <CODE>f{...}</CODE> is syntactic sugar for
<CODE>f({...})</CODE>, that is,
the parameter list is a single new table.
A call of the form <CODE>f'...'</CODE>
(or <CODE>f"..."</CODE> or <CODE>f[[...]]</CODE>) is syntactic sugar for
<CODE>f('...')</CODE>, that is,
the parameter list is a single literal string.
<P>
Because a function can return any number of results
(see Section&nbsp;<A HREF="#return">4.5.3</A>),
the number of results must be adjusted before used.
If the function is called as a statement (see Section&nbsp;<A HREF="#funcstat">4.5.5</A>),
then its return list is adjusted to&nbsp;0,
thus discarding all returned values.
If the function is called in a place that needs a single value
(syntactically denoted by the non-terminal <EM>exp1</EM>),
then its return list is adjusted to&nbsp;1,
thus discarding all returned values but the first one.
If the function is called in a place that can hold many values
(syntactically denoted by the non-terminal <EM>exp</EM>),
then no adjustment is made.
The only places that can hold many values
is the last (or the only) expression in an assignment,
in an argument list, or in a return statement;
see examples below.
<PRE>
      f();               -- adjusted to 0
      g(f(), x);         -- f() is adjusted to 1 result
      g(x, f());         -- g gets x plus all values returned by f()
      a,b,c = f(), x;    -- f() is adjusted to 1 result (and c gets nil)
      a,b,c = x, f();    -- f() is adjusted to 2
      a,b,c = f();       -- f() is adjusted to 3
      return f();        -- returns all values returned by f()
</PRE>
<P>
<A NAME="func-def"></A>
<H3>4.6.9 - <A NAME="Function Definitions</H3>">Function Definitions</H3></A> 
<P>
The syntax for function definition is
<PRE>
function ::= <B>function</B> '<B>(</B>' [parlist1] '<B>)</B>' block <B>end</B>
stat ::= <B>function</B> funcname '<B>(</B>' [parlist1] '<B>)</B>' block <B>end</B>
funcname ::= name | name '<B>.</B>' name
</PRE>
The statement
<PRE>
      function f (...)
        ...
      end
</PRE>
is just syntactic sugar for
<PRE>
      f = function (...)
            ...
          end
</PRE>
and
<PRE>
      function o.f (...)
        ...
      end
</PRE>
is syntactic sugar for
<PRE>
      o.f = function (...)
              ...
            end
</PRE>
<P>
A function definition is an executable expression,
whose value has type <EM>function</EM>.
When Lua pre-compiles a chunk,
all its function bodies are pre-compiled, too.
Then, whenever Lua executes the function definition,
its upvalues are fixed (see Section&nbsp;<A HREF="#upvalue">4.7</A>),
and the function is <EM>instantiated</EM> (or <EM>closed</EM>).
This function instance (or <EM>closure</EM>)
is the final value of the expression.
Different instances of the same function
may have different upvalues.
<P>
Parameters act as local variables,
initialized with the argument values:
<PRE>
parlist1 ::= '<B>...</B>'
parlist1 ::= name {'<B>,</B>' name} ['<B>,</B>' '<B>...</B>']
</PRE>
<A NAME="vararg"></A>

When a function is called,
the list of <A NAME="arguments">arguments</A> is adjusted to
the length of the list of parameters (see Section&nbsp;<A HREF="#adjust">4.4</A>),
unless the function is a <A NAME="vararg"><EM>vararg</EM></A> function,
indicated by the dots (...) at the end of its parameter list.
A vararg function does not adjust its argument list;
instead, it collects any extra arguments into an implicit parameter,
called <A NAME="arg"><TT>arg</TT></A>.
This parameter is always initialized as a table,
with a field <CODE>n</CODE> whose value is the number of extra arguments,
and the extra arguments at positions 1,&nbsp;2,&nbsp;....
<P>
As an example, suppose definitions like:
<PRE>
      function f(a, b) end
      function g(a, b, ...) end
      function r() return 1,2,3 end
</PRE>
Then, we have the following mapping from arguments to parameters:
<PRE>
      CALL            PARAMETERS
<P>
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
<P>
     g(3)             a=3, b=nil, arg={n=0}
     g(3, 4)          a=3, b=4, arg={n=0}
     g(3, 4, 5, 8)    a=3, b=4, arg={5, 8; n=2}
     g(5, r())        a=5, b=1, arg={2, 3; n=2}
</PRE>
<P>
Results are returned using the <CODE>return</CODE> statement (see Section&nbsp;<A HREF="#return">4.5.3</A>).
If control reaches the end of a function without a return instruction,
then the function returns with no results.
<P>
There is a special syntax for defining <A NAME="methods">methods</A>,
that is, functions that have an implicit extra parameter <A NAME="self"><TT>self</TT></A>:
<PRE>
function ::= <B>function</B> name '<B>:</B>' name '<B>(</B>' [parlist1] '<B>)</B>' block <B>end</B>
</PRE>
Thus, a declaration like
<PRE>
      function v:f (...)
        ...
      end
</PRE>
is equivalent to
<PRE>
      v.f = function (self, ...)
        ...
      end
</PRE>
that is, the function gets an extra formal parameter called <CODE>self</CODE>.
Note that the variable <CODE>v</CODE> must have been
previously initialized with a table value.
<P>
<P>
<A NAME="upvalue"></A>
<A NAME="4.7"></A>
<H2>4.7 - Visibility and Upvalues</H2> 
<A NAME="Visibility"></A> <A NAME="Upvalues"></A>
<P>
A function body may refer to its own local variables
(which include its parameters) and to global variables,
as long as they are not shadowed by local
variables from enclosing functions.
A function <EM>cannot</EM> access a local
variable from an enclosing function,
since such variables may no longer exist when the function is called.
However, a function may access the <EM>value</EM> of a local variable
from an enclosing function, using <EM>upvalues</EM>.
<P>
<PRE>
upvalue ::= '<B>%</B>' name
</PRE>
An upvalue is somewhat similar to a variable expression,
but whose value is frozen when the function wherein it
appears is instantiated.
The name used in an upvalue may be the name of any variable visible
at the point where the function is defined.
<P>
Here are some examples:
<PRE>
      a,b,c = 1,2,3   -- global variables
      function f (x)
        local b       -- x and b are local to f
        local g = function (a)
          local y     -- a and y are local to g
          p = a       -- OK, access local 'a'
          p = c       -- OK, access global 'c'
          p = b       -- ERROR: cannot access a variable in outer scope
          p = %b      -- OK, access frozen value of 'b' (local to 'f')
          p = %c      -- OK, access frozen value of global 'c'
          p = %y      -- ERROR: 'y' is not visible where 'g' is defined
        end           -- g
      end             -- f
</PRE>
<P>
<P>
<A NAME="tag-method"></A>
<A NAME="4.8"></A>
<H2>4.8 - Tag Methods</H2> 
<P>
Lua provides a powerful mechanism to extend its semantics,
called <A NAME="tag methods"><EM>tag methods</EM></A>.
A tag method is a programmer-defined function
that is called at specific key points during the evaluation of a program,
allowing the programmer to change the standard Lua behavior at these points.
Each of these points is called an <A NAME="event"><EM>event</EM></A>.
<P>
The tag method called for any specific event is selected
according to the tag of the values involved
in the event (see Section&nbsp;<A HREF="#TypesSec">3</A>).
The function <A NAME="settagmethod"><TT>settagmethod</TT></A> changes the tag method
associated with a given pair <EM>(tag, event)</EM>.
Its first parameter is the tag, the second parameter is the event name
(a string; see below),
and the third parameter is the new method (a function),
or <B>nil</B> to restore the default behavior for the pair.
The function returns the previous tag method for that pair.
Another function, <A NAME="gettagmethod"><TT>gettagmethod</TT></A>,
receives a tag and an event name and returns the
current method associated with the pair.
<P>
Tag methods are called in the following events,
identified by the given names.
The semantics of tag methods is better explained by a Lua function
describing the behavior of the interpreter at each event.
The function not only shows when a tag method is called,
but also its arguments, its results, and the default behavior.
Please notice that the code shown here is only illustrative;
the real behavior is hard coded in the interpreter,
and it is much more efficient than this simulation.
All functions used in these descriptions
(<CODE>rawgetglobal</CODE>, <CODE>tonumber</CODE>, <CODE>call</CODE>, etc.)
are described in Section&nbsp;<A HREF="#predefined">6.1</A>.
<P>
<DL>
<P>
<DT><B>``add'':</B><DD><A NAME="add event"></A>
called when a <CODE>+</CODE> operation is applied to non numerical operands.
<P>
The function <CODE>getbinmethod</CODE> defines how Lua chooses a tag method
for a binary operation.
First, Lua tries the first operand.
If its tag does not define a tag method for the operation,
then Lua tries the second operand.
If it also fails, then it gets a tag method from tag&nbsp;0:
<PRE>
      function getbinmethod (op1, op2, event)
        return gettagmethod(tag(op1), event) or
               gettagmethod(tag(op2), event) or
               gettagmethod(0, event)
      end
</PRE>
<PRE>
      function add_event (op1, op2)
        local o1, o2 = tonumber(op1), tonumber(op2)
        if o1 and o2 then  -- both operands are numeric
          return o1+o2  -- '+' here is the primitive 'add'
        else  -- at least one of the operands is not numeric
          local tm = getbinmethod(op1, op2, "add")
          if tm then
            -- call the method with both operands and an extra
            -- argument with the event name
            return tm(op1, op2, "add")
          else  -- no tag method available: default behavior
            error("unexpected type at arithmetic operation")
          end
        end
      end
</PRE>
<P>
<DT><B>``sub'':</B><DD><A NAME="sub event"></A>
called when a <CODE>-</CODE> operation is applied to non numerical operands.
Behavior similar to the <CODE>"add"</CODE> event.
<P>
<DT><B>``mul'':</B><DD><A NAME="mul event"></A>
called when a <CODE>*</CODE> operation is applied to non numerical operands.
Behavior similar to the <CODE>"add"</CODE> event.
<P>
<DT><B>``div'':</B><DD><A NAME="div event"></A>
called when a <CODE>/</CODE> operation is applied to non numerical operands.
Behavior similar to the <CODE>"add"</CODE> event.
<P>
<DT><B>``pow'':</B><DD><A NAME="pow event"></A>
called when a <CODE>^</CODE> operation is applied.
<PRE>
      function pow_event (op1, op2)
        local tm = getbinmethod(op1, op2, "pow")
        if tm then
          -- call the method with both operands and an extra
          -- argument with the event name
          return tm(op1, op2, "pow")
        else  -- no tag method available: default behavior
          error("unexpected type at arithmetic operation")
        end
      end
</PRE>
<P>
<DT><B>``unm'':</B><DD><A NAME="unm event"></A>
called when an unary <CODE>-</CODE> operation is applied to a non numerical operand.
<PRE>
      function unm_event (op)
        local o = tonumber(op)
        if o then  -- operand is numeric
          return -o  -- '-' here is the primitive 'unm'
        else  -- the operand is not numeric.
          -- Try to get a tag method from the operand;
          --  if it does not have one, try a "global" one (tag 0)
          local tm = gettagmethod(tag(op), "unm") or
                     gettagmethod(0, "unm")
          if tm then
            -- call the method with the operand, nil, and an extra
            -- argument with the event name
            return tm(op, nil, "unm")
          else  -- no tag method available: default behavior
            error("unexpected type at arithmetic operation")
          end
        end
      end
</PRE>
<P>
<DT><B>``lt'':</B><DD><A NAME="lt event"></A>
called when an order operation is applied to non-numerical
or non-string operands.
It corresponds to the <CODE>&lt;</CODE> operator.
<PRE>
      function lt_event (op1, op2)
        if type(op1) == "number" and type(op2) == "number" then
          return op1 &lt; op2   -- numeric comparison
        elseif type(op1) == "string" and type(op2) == "string" then
          return op1 &lt; op2   -- lexicographic comparison
        else
          local tm = getbinmethod(op1, op2, "lt")
          if tm then
            return tm(op1, op2, "lt")
          else
            error("unexpected type at comparison");
          end
        end
      end
</PRE>
The other order operators use this tag method according to the
usual equivalences:
<PRE>
   a&gt;b    &lt;=&gt;  b&lt;a
   a&lt;=b   &lt;=&gt;  not (b&lt;a)
   a&gt;=b   &lt;=&gt;  not (a&lt;b)
</PRE>
<P>
<DT><B>``concat'':</B><DD><A NAME="concatenation event"></A>
called when a concatenation is applied to non string operands.
<PRE>
      function concat_event (op1, op2)
        if (type(op1) == "string" or type(op1) == "number") and
           (type(op2) == "string" or type(op2) == "number") then
          return op1..op2  -- primitive string concatenation
        else
          local tm = getbinmethod(op1, op2, "concat")
          if tm then
            return tm(op1, op2, "concat")
          else
            error("unexpected type for concatenation")
          end
        end
      end
</PRE>
<P>
<DT><B>``index'':</B><DD><A NAME="index event"></A>
called when Lua tries to retrieve the value of an index
not present in a table.
See event <CODE>"gettable"</CODE> for its semantics.
<P>
<DT><B>``getglobal'':</B><DD><A NAME="getglobal event"></A>
called whenever Lua needs the value of a global variable.
This method can only be set for <B>nil</B> and for tags
created by <CODE>newtag</CODE>.
<PRE>
      function getglobal (varname)
        local value = rawgetglobal(varname)
        local tm = gettagmethod(tag(value), "getglobal")
        if not tm then
          return value
        else
          return tm(varname, value)
        end
      end
</PRE>
The function <CODE>getglobal</CODE> is pre-defined in Lua (see Section&nbsp;<A HREF="#predefined">6.1</A>).
<P>
<DT><B>``setglobal'':</B><DD><A NAME="setglobal event"></A>
called whenever Lua assigns to a global variable.
This method cannot be set for numbers, strings, and tables and
userdata with default tags.
<PRE>
      function setglobal (varname, newvalue)
        local oldvalue = rawgetglobal(varname)
        local tm = gettagmethod(tag(oldvalue), "setglobal")
        if not tm then
          rawsetglobal(varname, newvalue)
        else
          tm(varname, oldvalue, newvalue)
        end
      end
</PRE>
Notice: the function <CODE>setglobal</CODE> is pre-defined in Lua (see Section&nbsp;<A HREF="#predefined">6.1</A>).
<P>
<DT><B>``gettable'':</B><DD><A NAME="gettable event"></A>
called whenever Lua accesses an indexed variable.
This method cannot be set for tables with default tag.
<PRE>
      function gettable_event (table, index)
        local tm = gettagmethod(tag(table), "gettable")
        if tm then
          return tm(table, index)
        elseif type(table) ~= "table" then
          error("indexed expression not a table");
        else
          local v = rawgettable(table, index)
          tm = gettagmethod(tag(table), "index")
          if v == nil and tm then
            return tm(table, index)
          else
            return v
          end
        end
      end
</PRE>
<P>
<DT><B>``settable'':</B><DD><A NAME="settable event"></A>
called when Lua assigns to an indexed variable.
This method cannot be set for tables with default tag.
<PRE>
      function settable_event (table, index, value)
        local tm = gettagmethod(tag(table), "settable")
        if tm then
          tm(table, index, value)
        elseif type(table) ~= "table" then
          error("indexed expression not a table")
        else
          rawsettable(table, index, value)
        end
      end
</PRE>
<P>
<DT><B>``function'':</B><DD><A NAME="function event"></A>
called when Lua tries to call a non function value.
<PRE>
      function function_event (func, ...)
        if type(func) == "function" then
          return call(func, arg)
        else
          local tm = gettagmethod(tag(func), "function")
          if tm then
            for i=arg.n,1,-1 do
              arg[i+1] = arg[i]
            end
            arg.n = arg.n+1
            arg[1] = func
            return call(tm, arg)
          else
            error("call expression not a function")
          end
        end
      end
</PRE>
<P>
<DT><B>``gc'':</B><DD><A NAME="gc event"></A>
called when Lua is ``garbage collecting'' an userdata.
This tag method can be set only from C,
and cannot be set for an userdata with default tag.
For each userdata to be collected,
Lua does the equivalent of the following function:
<PRE>
      function gc_event (obj)
        local tm = gettagmethod(tag(obj), "gc")
        if tm then
          tm(obj)
        end
      end
</PRE>
Moreover, at the end of a garbage collection cycle,
Lua does the equivalent of the call <CODE>gc_event(nil)</CODE>.
<P>
</DL>
<P>
<P>
<P>
<A NAME="error"></A>
<A NAME="4.9"></A>
<H2>4.9 - Error Handling</H2> 
<P>
Because Lua is an extension language,
all Lua actions start from C code in the host program
calling a function from the Lua library.
Whenever an error occurs during Lua compilation or execution,
function <CODE>_ERRORMESSAGE</CODE> is called <A NAME="_ERRORMESSAGE"></A>
(provided it is different from <B>nil</B>),
and then the corresponding function from the library
(<CODE>lua_dofile</CODE>, <CODE>lua_dostring</CODE>,
<CODE>lua_dobuffer</CODE>, or <CODE>lua_callfunction</CODE>)
is terminated, returning an error condition.
<P>
The only argument to <CODE>_ERRORMESSAGE</CODE> is a string
describing the error.
The default definition for
this function calls <CODE>_ALERT</CODE>, <A NAME="_ALERT"></A>
which prints the message to <CODE>stderr</CODE> (see Section&nbsp;<A HREF="#alert">6.1</A>).
The standard I/O library redefines <CODE>_ERRORMESSAGE</CODE>,
and uses the debug facilities (see Section&nbsp;<A HREF="#debugI">7</A>)
to print some extra information,
such as the call stack.
<P>
To provide more information about errors,
Lua programs should include the compilation pragma <CODE>$debug</CODE>.
<A NAME="pragma"></A>
<A NAME="debug pragma"></A>
When an error occurs in a chunk compiled with this option,
the I/O error-message routine is able to print the number of the
lines where the calls (and the error) were made.
<P>
Lua code can explicitly generate an error by calling the built-in
function <CODE>error</CODE> (see Section&nbsp;<A HREF="#pdf-error">6.1</A>).
Lua code can ``catch'' an error using the built-in function
<CODE>call</CODE> (see Section&nbsp;<A HREF="#pdf-call">6.1</A>).
<P>
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="5."></A>
<H1>5 - The Application Program Interface</H1>
<P>
This section describes the API for Lua, that is,
the set of C functions available to the host program to communicate
with the Lua library.
The API functions can be classified in the following categories:
<OL>
<LI>managing states;
<LI>exchanging values between C and Lua;
<LI>executing Lua code;
<LI>manipulating (reading and writing) Lua objects;
<LI>calling Lua functions;
<LI>defining C functions to be called by Lua;
<LI>manipulating references to Lua Objects.
</OL>
All API functions and related types and constants
are declared in the header file <CODE>lua.h</CODE>.
<P>
Even when we use the term <EM>function</EM>,
<EM>any facility in the API may be provided as a macro instead</EM>.
Any of such macros uses once and only once each of its arguments.
<P>
<P>
<A NAME="mangstate"></A>
<A NAME="5.1"></A>
<H2>5.1 - States</H2> 
<P>
The Lua library is reentrant.
It does not have any global variable.
The whole state of the Lua interpreter
(global variables, stack, tag methods, etc)
is stored in a dynamic structure <A NAME="lua_State"></A>;
this state must be passed as the first argument to almost
every function in the library.
<P>
Before calling any API function,
you must create a state.
This is done by calling<A NAME="lua_newstate"></A>
<PRE>
lua_State *lua_newstate (const char *s, ...);
</PRE>
The arguments to this function is a list of name-value options,
terminated with <CODE>NULL</CODE>.
Currently, the function accepts the following options:
<UL>
<LI><CODE>"stack"</CODE> - the stack size.
Each function call needs one stack position for each local variable
and temporary variables, plus one position.
The stack must also have at least ten extra positions available.
For very small implementations, without recursive functions,
a size of 100 should be enough.
The default is 1K.
<P>
<LI><CODE>"builtin"</CODE> - the value is a boolean (0 or 1) that
indicates whether the predefined functions should be loaded or not.
The default is to load those functions.
</UL>
For instance, the call
<PRE>
lua_State *L = lua_newstate(NULL);
</PRE>
creates a new state with a stack of 1K positions,
and with the predefined functions loaded;
the call
<PRE>
lua_State *L = lua_newstate("builtin", 0, "stack", 100, NULL);
</PRE>
creates a new state with a stack of 100 positions,
without the predefined functions.
<P>
To release a state, you call
<PRE>
void lua_close (lua_State *L);
</PRE>
This function destroys all objects in the current Lua environment
(calling the correspondent garbage collector tag methods),
and frees all dynamic memory used by the state.
Usually, you do not need to call this function,
because these resources are naturally released when the program ends.
<P>
With the exception of <CODE>lua_newstate</CODE>,
all functions in the API get at its first argument a state.
However, most applications use a single state.
To avoid the burden of passing this only state explicitly to all
functions, and also to keep compatibility with old versions of Lua,
the API provides a set of macros and one global variable that
take care of this state argument for single-state applications:
<PRE>
#ifndef LUA_REENTRANT
</PRE>
<PRE>
extern lua_State *lua_state;
</PRE>
<PRE>
#define lua_close()             (lua_close)(lua_state)
#define lua_dofile(filename)    (lua_dofile)(lua_state, filename)
#define lua_dostring(str)       (lua_dostring)(lua_state, str)
   ...
</PRE>
<PRE>
#endif
</PRE>
For each function in the API, there is a macro with the same name
that supplies <CODE>lua_state</CODE> as the first argument to the call.
(The parentheses around the function name avoid it being expanded
again as a macro.)
The only exception is <CODE>lua_newstate</CODE>;
in this case, the corresponding macro is
<PRE>
#define lua_open()      ((void)(lua_state?0:(lua_state=lua_newstate(0))))
</PRE>
It checks whether the global state has been initialized;
if not, it creates a new state with default settings and
assigns it to <CODE>lua_newstate</CODE>.
<P>
By default, those macros are all active.
If you will use multiple states,
and therefore will want to provide the state
argument explicitly for each call,
you should define <A NAME="LUA_REENTRANT"><TT>LUA_REENTRANT</TT></A> before
including <CODE>lua.h</CODE> in your code:
<PRE>
#define LUA_REENTRANT
#include "lua.h"
</PRE>
<P>
In the sequel, we will show all functions in the single-state form
(therefore, they are actually macros).
When you define <CODE>LUA_REENTRANT</CODE>,
all of them get a state as the first parameter.
<P>
<P>
<A NAME="valuesCLua"></A>
<A NAME="5.2"></A>
<H2>5.2 - Exchanging Values between C and Lua</H2> 
Because Lua has no static type system,
all values passed between Lua and C have type
<CODE>lua_Object</CODE><A NAME="lua_Object"></A>,
which works like an abstract type in C that can hold any Lua value.
Values of type <CODE>lua_Object</CODE> have no meaning outside Lua;
for instance,
you cannot compare two <CODE>lua_Object's</CODE> directly.
Instead, you should use the next function:
<A NAME="lua_equal"></A>
<PRE>
int lua_equal       (lua_Object o1, lua_Object o2);
</PRE>
<P>
To check the type of a <CODE>lua_Object</CODE>,
the following functions are available:
<A NAME="lua_isnil"></A><A NAME="lua_isnumber"></A><A NAME="lua_isstring"></A>
<A NAME="lua_istable"></A><A NAME="lua_iscfunction"></A><A NAME="lua_isuserdata"></A>
<A NAME="lua_isfunction"></A>
<A NAME="lua_type"></A>
<PRE>
int lua_isnil       (lua_Object object);
int lua_isnumber    (lua_Object object);
int lua_isstring    (lua_Object object);
int lua_istable     (lua_Object object);
int lua_isfunction  (lua_Object object);
int lua_iscfunction (lua_Object object);
int lua_isuserdata  (lua_Object object);
const char *lua_type (lua_Object obj);
</PRE>
The <CODE>lua_is*</CODE> functions return 1 if the object is compatible
with the given type, and 0 otherwise.
The function <CODE>lua_isnumber</CODE> accepts numbers and numerical strings,
<CODE>lua_isstring</CODE> accepts strings and numbers (see Section&nbsp;<A HREF="#coercion">4.3</A>),
and <CODE>lua_isfunction</CODE> accepts Lua functions and C functions.
To distinguish between Lua functions and C functions,
you should use <CODE>lua_iscfunction</CODE>.
To distinguish between numbers and numerical strings,
you can use <CODE>lua_type</CODE>.
The <CODE>lua_type</CODE> returns one of the following strings,
describing the type of the given object:
<CODE>"nil"</CODE>, <CODE>"number"</CODE>, <CODE>"string"</CODE>, <CODE>"table"</CODE>,
<CODE>"function"</CODE>, <CODE>"userdata"</CODE>, or <CODE>"NOOBJECT"</CODE>.
<P>
To get the tag of a <CODE>lua_Object</CODE>,
the following function is available:
<A NAME="lua_tag"></A>
<PRE>
int lua_tag (lua_Object object);
</PRE>
<P>
To translate a value from type <CODE>lua_Object</CODE> to a specific C type,
you can use
<A NAME="lua_getnumber"></A><A NAME="lua_getstring"></A><A NAME="lua_strlen"></A>
<A NAME="lua_getcfunction"></A><A NAME="lua_getuserdata"></A>
<PRE>
double         lua_getnumber    (lua_Object object);
const char    *lua_getstring    (lua_Object object);
long           lua_strlen       (lua_Object object);
lua_CFunction  lua_getcfunction (lua_Object object);
void          *lua_getuserdata  (lua_Object object);
</PRE>
<P>
<CODE>lua_getnumber</CODE> converts a <CODE>lua_Object</CODE> to a floating-point number.
This <CODE>lua_Object</CODE> must be a number or a string convertible to number
(see Section&nbsp;<A HREF="#coercion">4.3</A>); otherwise, <CODE>lua_getnumber</CODE> returns&nbsp;0.
<P>
<CODE>lua_getstring</CODE> converts a <CODE>lua_Object</CODE> to a string
(<CODE>const char*</CODE>).
This <CODE>lua_Object</CODE> must be a string or a number;
otherwise, the function returns <CODE>NULL</CODE>.
This function does not create a new string,
but returns a pointer to a string inside the Lua environment.
Those strings always have a 0 after their last character (like in C),
but may contain other zeros in their body.
If you do not know whether a string may contain zeros,
you can use <CODE>lua_strlen</CODE> to get the actual length.
Because Lua has garbage collection,
there is no guarantee that the pointer returned by <CODE>lua_getstring</CODE>
will be valid after the block ends
(see Section&nbsp;<A HREF="#GC">5.3</A>).
<P>
<CODE>lua_getcfunction</CODE> converts a <CODE>lua_Object</CODE> to a C function.
This <CODE>lua_Object</CODE> must have type <EM>CFunction</EM>;
otherwise, <CODE>lua_getcfunction</CODE> returns <CODE>NULL</CODE>.
The type <CODE>lua_CFunction</CODE> is explained in Section&nbsp;<A HREF="#LuacallC">5.7</A>.
<P>
<CODE>lua_getuserdata</CODE> converts a <CODE>lua_Object</CODE> to <CODE>void*</CODE>.
This <CODE>lua_Object</CODE> must have type <EM>userdata</EM>;
otherwise, <CODE>lua_getuserdata</CODE> returns <CODE>NULL</CODE>.
<P>
<A NAME="GC"></A>
<A NAME="5.3"></A>
<H2>5.3 - Garbage Collection</H2>
Because Lua has automatic memory management and garbage collection,
a <CODE>lua_Object</CODE> has a limited scope,
and is only valid inside the <EM>block</EM> where it has been created.
A C function called from Lua is a block,
and its parameters are valid only until its end.
It is good programming practice to convert Lua objects to C values
as soon as they are available,
and never to store <CODE>lua_Object</CODE>s in C global variables.
<P>
A garbage collection cycle can be forced by:
<A NAME="lua_collectgarbage"></A>
<PRE>
long lua_collectgarbage (long limit);
</PRE>
This function returns the number of objects collected.
The argument <CODE>limit</CODE> makes the next cycle occur only
after that number of new objects have been created.
If <CODE>limit</CODE> is 0,
then Lua uses an adaptive heuristics to set this limit.
<P>
<P>
All communication between Lua and C is done through two
abstract data types, called <A NAME="lua2C"><EM>lua2C</EM></A> and <A NAME="C2lua"><EM>C2lua</EM></A>.
The first one, as the name implies, is used to pass values
from Lua to C:
parameters when Lua calls C and results when C calls Lua.
The structure C2lua is used in the reverse direction:
parameters when C calls Lua and results when Lua calls C.
<P>
The structure lua2C is an abstract array,
which can be indexed with the function:
<A NAME="lua_lua2C"></A>
<PRE>
lua_Object lua_lua2C (int number);
</PRE>
where <CODE>number</CODE> starts with 1.
When called with a number larger than the array size,
this function returns <CODE>LUA_NOOBJECT</CODE><A NAME="LUA_NOOBJECT"></A>.
In this way, it is possible to write C functions that receive
a variable number of parameters,
and to call Lua functions that return a variable number of results.
Note that the structure lua2C cannot be directly modified by C code.
<P>
The second structure, C2lua, is an abstract stack.
Pushing elements into this stack
is done with the following functions:
<A NAME="lua_pushnumber"></A><A NAME="lua_pushlstring"></A><A NAME="lua_pushstring"></A>
<A NAME="lua_pushcfunction"></A><A NAME="lua_pushusertag"></A>
<A NAME="lua_pushnil"></A><A NAME="lua_pushobject"></A>
<A NAME="pushing"></A>
<A NAME="lua_pushuserdata"></A>
<PRE>
void lua_pushnumber    (double n);
void lua_pushlstring   (const char *s, long len);
void lua_pushstring    (const char *s);
void lua_pushusertag   (void *u, int tag);
void lua_pushnil       (void);
void lua_pushobject    (lua_Object object);
void lua_pushcfunction (lua_CFunction f);  /* macro */
</PRE>
All of them receive a C value,
convert it to a corresponding <CODE>lua_Object</CODE>,
and leave the result on the top of C2lua.
In particular, functions <CODE>lua_pushlstring</CODE> and <CODE>lua_pushstring</CODE>
make an internal copy of the given string.
Function <CODE>lua_pushstring</CODE> can only be used to push proper C strings
(that is, strings that end with a zero and do not contain embedded zeros);
otherwise you should use the more generic <CODE>lua_pushlstring</CODE>.
The function
<A NAME="lua_pop"></A>
<PRE>
lua_Object lua_pop (void);
</PRE>
returns a reference to the object at the top of the C2lua stack,
and pops it.
<P>
As a general rule, all API functions pop from the stack
all elements they use.
<P>
Because userdata are objects,
the function <CODE>lua_pushusertag</CODE> may create a new userdata.
If Lua has a userdata with the given value (<CODE>void*</CODE>) and tag,
that userdata is pushed.
Otherwise, a new userdata is created, with the given value and tag.
If this function is called with
<CODE>tag</CODE> equal to <CODE>LUA_ANYTAG</CODE><A NAME="LUA_ANYTAG"></A>,
then Lua will try to find any userdata with the given value,
regardless of its tag.
If there is no userdata with that value, then a new one is created,
with tag equal to 0.
<P>
Userdata can have different tags,
whose semantics are only known to the host program.
Tags are created with the function:
<A NAME="lua_newtag"></A>
<PRE>
int lua_newtag (void);
</PRE>
The function <CODE>lua_settag</CODE> changes the tag of
the object on the top of C2lua (and pops it);
the object must be a userdata or a table.
<A NAME="lua_settag"></A>
<PRE>
void lua_settag (int tag);
</PRE>
<CODE>tag</CODE> must be a value created with <CODE>lua_newtag</CODE>.
<P>
When C code calls Lua repeatedly, as in a loop,
objects returned by these calls can accumulate,
and may cause a stack overflow.
To avoid this,
nested blocks can be defined with the functions:
<PRE>
void lua_beginblock (void);
void lua_endblock   (void);
</PRE>
After the end of the block,
all <CODE>lua_Object</CODE>'s created inside it are released.
The use of explicit nested blocks is good programming practice
and is strongly encouraged.
<P>
<A NAME="5.4"></A>
<H2>5.4 - Executing Lua Code</H2>
A host program can execute Lua chunks written in a file or in a string
using the following functions:
<A NAME="lua_dofile"></A><A NAME="lua_dostring"></A><A NAME="lua_dobuffer"></A>
<PRE>
int lua_dofile   (const char *filename);
int lua_dostring (const char *string);
int lua_dobuffer (const char *buff, int size, const char *name);
</PRE>
All these functions return an error code:
0, in case of success; non zero, in case of errors.
More specifically, <CODE>lua_dofile</CODE> returns 2 if for any reason
it could not open the file.
When called with argument <CODE>NULL</CODE>,
<CODE>lua_dofile</CODE> executes the <CODE>stdin</CODE> stream.
Functions <CODE>lua_dofile</CODE> and <CODE>lua_dobuffer</CODE>
are both able to execute pre-compiled chunks.
They automatically detect whether the chunk is text or binary,
and load it accordingly (see program <A NAME="luac"><TT><A HREF="luac.html">luac</A></TT></A>).
Function <CODE>lua_dostring</CODE> executes only source code.
<P>
The third parameter to <CODE>lua_dobuffer</CODE> (<CODE>name</CODE>)
is the ``name of the chunk'',
used in error messages and debug information.
If <CODE>name</CODE> is <CODE>NULL</CODE>,
Lua gives a default name to the chunk.
<P>
These functions return, in structure lua2C,
any values eventually returned by the chunks.
They also empty the stack C2lua.
<P>
<P>
<A NAME="5.5"></A>
<H2>5.5 - Manipulating Lua Objects</H2>
To read the value of any global Lua variable,
one uses the function:
<A NAME="lua_getglobal"></A>
<PRE>
lua_Object lua_getglobal (const char *varname);
</PRE>
As in Lua, this function may trigger a tag method.
To read the real value of any global variable,
without invoking any tag method,
use the <EM>raw</EM> version:
<A NAME="lua_rawgetglobal"></A>
<PRE>
lua_Object lua_rawgetglobal (const char *varname);
</PRE>
<P>
To store a value previously pushed onto C2lua in a global variable,
there is the function:
<A NAME="lua_setglobal"></A>
<PRE>
void lua_setglobal (const char *varname);
</PRE>
As in Lua, this function may trigger a tag method.
To set the real value of any global variable,
without invoking any tag method,
use the <EM>raw</EM> version:
<A NAME="lua_rawgetglobal"></A>
<PRE>
void lua_rawsetglobal (const char *varname);
</PRE>
<P>
Tables can also be manipulated via the API.
The function
<A NAME="lua_gettable"></A>
<PRE>
lua_Object lua_gettable (void);
</PRE>
pops a table and an index from the stack C2lua,
and returns the contents of the table at that index.
As in Lua, this operation may trigger a tag method.
To get the real value of any table index,
without invoking any tag method,
use the <EM>raw</EM> version:
<A NAME="lua_rawgetglobal"></A>
<PRE>
lua_Object lua_rawgettable (void);
</PRE>
<P>
To store a value in an index,
the program must push the table, the index,
and the value onto C2lua,
and then call the function
<A NAME="lua_settable"></A>
<PRE>
void lua_settable (void);
</PRE>
Again, the tag method for ``settable'' may be called.
To set the real value of any table index,
without invoking any tag method,
use the <EM>raw</EM> version:
<A NAME="lua_rawsettable"></A>
<PRE>
void lua_rawsettable (void);
</PRE>
<P>
Finally, the function
<A NAME="lua_createtable"></A>
<PRE>
lua_Object lua_createtable (void);
</PRE>
creates and returns a new, empty table.
<P>
<P>
<A NAME="5.6"></A>
<H2>5.6 - Calling Lua Functions</H2>
Functions defined in Lua by a chunk
can be called from the host program.
This is done using the following protocol:
first, the arguments to the function are pushed onto C2lua
(see Section&nbsp;<A HREF="#pushing">5.3</A>), in direct order, i.e., the first argument is pushed first.
Then, the function is called using
<A NAME="lua_callfunction"></A>
<PRE>
int lua_callfunction (lua_Object function);
</PRE>
This function returns an error code:
0, in case of success; non zero, in case of errors.
Finally, the results are returned in structure lua2C
(recall that a Lua function may return many values),
and can be retrieved with the macro <CODE>lua_getresult</CODE>,
<A NAME="lua_getresult"></A>
which is just another name to function <CODE>lua_lua2C</CODE>.
Note that function <CODE>lua_callfunction</CODE>
pops all elements from the C2lua stack.
<P>
The following example shows how a C program may do the
equivalent to the Lua code:
<PRE>
      a,b = f("how", t.x, 4)
</PRE>
<PRE>
  lua_pushstring("how");                               /* 1st argument */
  lua_pushobject(lua_getglobal("t"));      /* push value of global 't' */
  lua_pushstring("x");                          /* push the string 'x' */
  lua_pushobject(lua_gettable());      /* push result of t.x (2nd arg) */
  lua_pushnumber(4);                                   /* 3rd argument */
  lua_callfunction(lua_getglobal("f"));           /* call Lua function */
  lua_pushobject(lua_getresult(1));   /* push first result of the call */
  lua_setglobal("a");                       /* set global variable 'a' */
  lua_pushobject(lua_getresult(2));  /* push second result of the call */
  lua_setglobal("b");                       /* set global variable 'b' */
</PRE>
<P>
Some special Lua functions have exclusive interfaces.
A C function can generate a Lua error calling the function
<A NAME="lua_error"></A>
<PRE>
void lua_error (const char *message);
</PRE>
This function never returns.
If the C function has been called from Lua,
then the corresponding Lua execution terminates,
as if an error had occurred inside Lua code.
Otherwise, the whole host program terminates with a call to <CODE>exit(1)</CODE>.
The <CODE>message</CODE> is passed to the error handler function,
<CODE>_ERRORMESSAGE</CODE>.
If <CODE>message</CODE> is <CODE>NULL</CODE>,
then <CODE>_ERRORMESSAGE</CODE> is not called.
<P>
Tag methods can be changed with: <A NAME="lua_settagmethod"></A>
<PRE>
lua_Object lua_settagmethod (int tag, const char *event);
</PRE>
The first parameter is the tag,
and the second is the event name (see Section&nbsp;<A HREF="#tag-method">4.8</A>);
the new method is pushed from C2lua.
This function returns a <CODE>lua_Object</CODE>,
which is the old tag method value.
To get just the current value of a tag method,
use the function <A NAME="lua_gettagmethod"></A>
<PRE>
lua_Object lua_gettagmethod (int tag, const char *event);
</PRE>
<P>
It is also possible to copy all tag methods from one tag
to another: <A NAME="lua_copytagmethods"></A>
<PRE>
int lua_copytagmethods (int tagto, int tagfrom);
</PRE>
This function returns <CODE>tagto</CODE>.
<P>
You can traverse a table with the function <A NAME="lua_next"></A>
<PRE>
int lua_next (lua_Object t, int i);
</PRE>
Its first argument is the table to be traversed,
and the second is a <EM>cursor</EM>;
this cursor starts in 0,
and for each call the function returns a value to
be used in the next call,
or 0 to signal the end of the traverse.
The function also returns, in the Lua2C array,
a key-value pair from the table.
A typical traversal looks like the following code:
<PRE>
  int i;
  lua_Object t;
  ...   /* gets the table at `t' */
  i = 0;
  lua_beginblock();
  while ((i = lua_next(t, i)) != 0) {
    lua_Object key = lua_getresult(1);
    lua_Object value = lua_getresult(2);
    ...  /* uses `key' and `value' */
    lua_endblock();
    lua_beginblock();  /* reopens a block */
  }
  lua_endblock();
</PRE>
The pairs of <CODE>lua_beginblock</CODE>/<CODE>lua_endblock</CODE> remove the
results of each iteration from the stack.
Without them, a traversal of a large table will overflow the stack.
<P>
To traverse the global variables, you use <A NAME="lua_nextvar"></A>
<PRE>
const char *lua_nextvar (const char *varname);
</PRE>
Here, the cursor is a string;
in the first call you set it to <CODE>NULL</CODE>;
for each call the function returns the name of a global variable,
to be used in the next call,
or <CODE>NULL</CODE> to signal the end of the traverse.
The function also returns, in the Lua2C array,
the name (again) and the value of the global variable.
A typical traversal looks like the following code:
<PRE>
  const char *name = NULL;
  lua_beginblock();
  while ((name = lua_nextvar(name)) != NULL) {
    lua_Object value = lua_getresult(2);
    ...  /* uses `name' and `value' */
    lua_endblock();
    lua_beginblock();  /* reopens a block */
  }
  lua_endblock();
</PRE>
<P>
<P>
<A NAME="LuacallC"></A>
<A NAME="5.7"></A>
<H2>5.7 - Defining C Functions</H2> 
To register a C function to Lua,
there is the following macro:
<A NAME="lua_register"></A>
<PRE>
#define lua_register(n,f)       (lua_pushcfunction(f), lua_setglobal(n))
/* const char *n;   */
/* lua_CFunction f; */
</PRE>
which receives the name the function will have in Lua,
and a pointer to the function.
This pointer must have type <CODE>lua_CFunction</CODE>,
which is defined as
<A NAME="lua_CFunction"></A>
<PRE>
typedef void (*lua_CFunction) (void);
</PRE>
that is, a pointer to a function with no parameters and no results.
<P>
In order to communicate properly with Lua,
a C function must follow a protocol,
which defines the way parameters and results are passed.
<P>
A C function receives its arguments in structure lua2C;
to access them, it uses the macro <CODE>lua_getparam</CODE>, <A NAME="lua_getparam"></A>
again just another name for <CODE>lua_lua2C</CODE>.
To return values, a C function just pushes them onto the stack C2lua,
in direct order (see Section&nbsp;<A HREF="#valuesCLua">5.2</A>).
Like a Lua function, a C function called by Lua can also return
many results.
<P>
When a C function is created,
it is possible to associate some <EM>upvalues</EM> to it,
thus creating a C closure;
then these values are passed to the function whenever it is called,
as common arguments.
To associate upvalues to a function,
first these values must be pushed on C2lua.
Then the function <A NAME="lua_pushcclosure"></A>
<PRE>
void lua_pushcclosure (lua_CFunction fn, int n);
</PRE>
is used to put the C function on C2lua,
with the argument <CODE>n</CODE> telling how many upvalues must be
associated with the function;
in fact, the macro <CODE>lua_pushcfunction</CODE> is defined as
<CODE>lua_pushcclosure</CODE> with <CODE>n</CODE> set to 0.
Then, any time the function is called,
these upvalues are inserted as the first arguments to the function,
before the actual arguments provided in the call.
<P>
For some examples of C functions, see files <CODE>lstrlib.c</CODE>,
<CODE>liolib.c</CODE> and <CODE>lmathlib.c</CODE> in the official Lua distribution.
<P>
<A NAME="5.8"></A>
<H2>5.8 - References to Lua Objects</H2>
<P>
As noted in Section&nbsp;<A HREF="#GC">5.3</A>, <CODE>lua_Object</CODE>s are volatile.
If the C code needs to keep a <CODE>lua_Object</CODE>
outside block boundaries,
then it must create a <A NAME="reference"><EM>reference</EM></A> to the object.
The routines to manipulate references are the following:
<A NAME="lua_ref"></A><A NAME="lua_getref"></A>
<A NAME="lua_unref"></A>
<PRE>
int        lua_ref    (int lock);
lua_Object lua_getref (int ref);
void       lua_unref  (int ref);
</PRE>
The function <CODE>lua_ref</CODE> creates a reference
to the object that is on the top of the stack,
and returns this reference.
For a <B>nil</B>{} object,
the reference is always <CODE>LUA_REFNIL</CODE>;<A NAME="LUA_REFNIL"></A>
otherwise, it is a non-negative integer.
The constant <CODE>LUA_NOREF</CODE> <A NAME="LUA_NOREF"></A>
is different from any valid reference.
If <CODE>lock</CODE> is true, the object is <EM>locked</EM>:
this means the object will not be garbage collected.
Note that an unlocked reference may be garbage collected.
Whenever the referenced object is needed,
a call to <CODE>lua_getref</CODE>
returns a handle to it;
if the object has been collected,
<CODE>lua_getref</CODE> returns <CODE>LUA_NOOBJECT</CODE>.
<P>
When a reference is no longer needed,
it can be released with a call to <CODE>lua_unref</CODE>.
<P>
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="6."></A>
<H1>6 - Predefined Functions and Libraries</H1>
<P>
The set of <A NAME="predefined functions">predefined functions</A> in Lua is small but powerful.
Most of them provide features that allow some degree of
<A NAME="reflexivity">reflexivity</A> in the language.
Some of these features cannot be simulated with the rest of the
language nor with the standard Lua API.
Others are just convenient interfaces to common API functions.
<P>
The libraries, on the other hand, provide useful routines
that are implemented directly through the standard API.
Therefore, they are not necessary to the language,
and are provided as separate C modules.
Currently, there are three standard libraries:
<UL>
<LI>string manipulation;
<LI>mathematical functions (sin, log, etc);
<LI>input and output (plus some system facilities).
</UL>
To have access to these libraries,
the C host program must call the functions
<CODE>lua_strlibopen</CODE>, <CODE>lua_mathlibopen</CODE>,
and <CODE>lua_iolibopen</CODE>, declared in <CODE>lualib.h</CODE>.
<A NAME="lua_strlibopen"></A><A NAME="lua_mathlibopen"></A><A NAME="lua_iolibopen"></A>
<P>
<P>
<A NAME="predefined"></A>
<A NAME="6.1"></A>
<H2>6.1 - Predefined Functions</H2> 
<P>
<h3> <TT>call (func, arg [, mode [, errhandler]])</TT></h3><A NAME="call"></A>
<A NAME="pdf-call"></A>

Calls function <CODE>func</CODE> with
the arguments given by the table <CODE>arg</CODE>.
The call is equivalent to
<PRE>
      func(arg[1], arg[2], ..., arg[n])
</PRE>
where <CODE>n</CODE> is the result of <CODE>getn(arg)</CODE> (see Section&nbsp;<A HREF="#getn">6.1</A>).
<P>
By default,
all results from <CODE>func</CODE> are just returned by the call.
If the string <CODE>mode</CODE> contains <CODE>"p"</CODE>,
the results are <EM>packed</EM> in a single table.<A NAME="packed results"></A>
That is, <CODE>call</CODE> returns just one table;
at index <CODE>n</CODE>, the table has the total number of results
from the call;
the first result is at index 1, etc.
For instance, the following calls produce the following results:
<PRE>
a = call(sin, {5})                --&gt; a = 0.0871557 = sin(5)
a = call(max, {1,4,5; n=2})       --&gt; a = 4 (only 1 and 4 are arguments)
a = call(max, {1,4,5; n=2}, "p")  --&gt; a = {4; n=1}
t = {x=1}
a = call(next, {t,nil;n=2}, "p")  --&gt; a={"x", 1; n=2}
</PRE>
<P>
By default,
if an error occurs during the function call,
the error is propagated.
If the string <CODE>mode</CODE> contains <CODE>"x"</CODE>,
then the call is <EM>protected</EM>.<A NAME="protected calls"></A>
In this mode, function <CODE>call</CODE> does not propagate an error,
regardless of what happens during the call.
Instead, it returns <B>nil</B> to signal the error
(besides calling the appropriated error handler).
<P>
If provided,
<CODE>errhandler</CODE> is temporarily set as the error function
<CODE>_ERRORMESSAGE</CODE>, while <CODE>func</CODE> runs.
In particular, if <CODE>errhandler</CODE> is <B>nil</B>,
no error messages will be issued during the execution of the called function.
<P>
<h3> <TT>collectgarbage ([limit])</TT></h3><A NAME="collectgarbage"></A>
Forces a garbage collection cycle.
Returns the number of objects collected.
An optional argument, <CODE>limit</CODE>, is a number that
makes the next cycle occur only after that number of new
objects have been created.
If <CODE>limit</CODE> is absent or equal to 0,
Lua uses an adaptive algorithm to set this limit.
<CODE>collectgarbage</CODE> is equivalent to
the API function <CODE>lua_collectgarbage</CODE>.
<P>
<h3> <TT>dofile (filename)</TT></h3><A NAME="dofile"></A>
Receives a file name,
opens the file, and executes the file contents as a Lua chunk,
or as pre-compiled chunks.
When called without arguments,
<CODE>dofile</CODE> executes the contents of the standard input (<CODE>stdin</CODE>).
If there is any error executing the file,
then <CODE>dofile</CODE> returns <B>nil</B>.
Otherwise, it returns the values returned by the chunk,
or a non <B>nil</B> value if the chunk returns no values.
It issues an error when called with a non string argument.
<CODE>dofile</CODE> is equivalent to the API function <CODE>lua_dofile</CODE>.
<P>
<h3> <TT>dostring (string [, chunkname])</TT></h3><A NAME="dostring"></A>
Executes a given string as a Lua chunk.
If there is any error executing the string,
<CODE>dostring</CODE> returns <B>nil</B>.
Otherwise, it returns the values returned by the chunk,
or a non <B>nil</B> value if the chunk returns no values.
An optional second parameter (<CODE>chunkname</CODE>)
is the ``name of the chunk'',
used in error messages and debug information.
<CODE>dostring</CODE> is equivalent to the API function <CODE>lua_dostring</CODE>.
<P>
<A NAME="pdf-newtag"></A>
<h3> <TT>newtag ()</TT></h3><A NAME="newtag"></A>
Returns a new tag.
<CODE>newtag</CODE> is equivalent to the API function <CODE>lua_newtag</CODE>.
<P>
<h3> <TT>next (table, [index])</TT></h3><A NAME="next"></A>
Allows a program to traverse all fields of a table.
Its first argument is a table and its second argument
is an index in this table.
It returns the next index of the table and the
value associated with the index.
When called with <B>nil</B> as its second argument,
the function returns the first index
of the table (and its associated value).
When called with the last index,
or with <B>nil</B> in an empty table,
it returns <B>nil</B>.
If the second argument is absent, it is interpreted as <B>nil</B>.
<P>
Lua has no declaration of fields;
semantically, there is no difference between a
field not present in a table or a field with value <B>nil</B>.
Therefore, the function only considers fields with non <B>nil</B> values.
The order in which the indices are enumerated is not specified,
<EM>even for numeric indices</EM>
(to traverse a table in numeric order,
use a counter or the function <CODE>foreachi</CODE>).
If you create new indices in a table while
traversing it,
the semantics of <CODE>next</CODE> is undefined.
<P>
<h3> <TT>nextvar (name)</TT></h3><A NAME="nextvar"></A>
This function is similar to the function <CODE>next</CODE>,
but iterates instead over the global variables.
Its single argument is the name of a global variable,
or <B>nil</B> to get a first name.
If this argument is absent, it is interpreted as <B>nil</B>.
Similarly to <CODE>next</CODE>, it returns the name of another variable
and its value,
or <B>nil</B> if there are no more variables.
If you create new global variables during the traversal,
the semantics of <CODE>nextvar</CODE> is undefined.
<P>
<h3> <TT>tostring (e)</TT></h3><A NAME="tostring"></A>
Receives an argument of any type and
converts it to a string in a reasonable format.
For complete control on how numbers are converted,
use function <CODE>format</CODE>.
<P>
<h3> <TT>print (e1, e2, ...)</TT></h3><A NAME="print"></A>
Receives any number of arguments,
and prints their values using the strings returned by <CODE>tostring</CODE>.
This function is not intended for formatted output,
but only as a quick way to show a value,
for instance for debugging.
See Section&nbsp;<A HREF="#libio">6.4</A> for functions for formatted output.
<P>
<A NAME="alert"></A>
<h3> <TT>_ALERT (message)</TT></h3><A NAME="alert"></A>
Prints its only string argument to <A NAME="stderr"><TT>stderr</TT></A>.
All error messages in Lua are printed through the function stored
in the <CODE>_ALERT</CODE> global variable.
Therefore, a program may assign another function to this variable
to change the way such messages are shown
(for instance, for systems without <CODE>stderr</CODE>).
<P>
<h3> <TT>tonumber (e [, base])</TT></h3><A NAME="tonumber"></A>
Receives one argument,
and tries to convert it to a number.
If the argument is already a number or a string convertible
to a number, then <CODE>tonumber</CODE> returns that number;
otherwise, it returns <B>nil</B>.
<P>
An optional argument specifies the base to interpret the numeral.
The base may be any integer between 2 and 36 inclusive.
In bases above  10, the letter `A' (either upper or lower case)
represents 10, `B' represents 11, and so forth, with `Z' representing 35.
<P>
In base 10 (the default), the number may have a decimal part,
as well as an optional exponent part (see Section&nbsp;<A HREF="#coercion">4.3</A>).
In other bases, only unsigned integers are accepted.
<P>
<A NAME="pdf-type"></A>
<h3> <TT>type (v)</TT></h3><A NAME="type"></A>
Allows Lua to test the type of a value.
It receives one argument, and returns its type, coded as a string.
The possible results of this function are
<CODE>"nil"</CODE> (a string, not the value <B>nil</B>),
<CODE>"number"</CODE>,
<CODE>"string"</CODE>,
<CODE>"table"</CODE>,
<CODE>"function"</CODE>,
and <CODE>"userdata"</CODE>.
<P>
<A NAME="pdf-tag"></A>
<h3> <TT>tag (v)</TT></h3><A NAME="tag"></A>
Allows Lua to test the tag of a value (see Section&nbsp;<A HREF="#TypesSec">3</A>).
It receives one argument, and returns its tag (a number).
<CODE>tag</CODE> is equivalent to the API function <CODE>lua_tag</CODE>.
<P>
<h3> <TT>settag (t, tag)</TT></h3><A NAME="settag"></A>
Sets the tag of a given table (see Section&nbsp;<A HREF="#TypesSec">3</A>).
<CODE>tag</CODE> must be a value created with <CODE>newtag</CODE>
(see Section&nbsp;<A HREF="#pdf-newtag">6.1</A>).
It returns the value of its first argument (the table).
For security reasons,
it is impossible to change the tag of a userdata from Lua.
<P>
<P>
<h3> <TT>assert (v [, message])</TT></h3><A NAME="assert"></A>
Issues an <EM>``assertion failed!''</EM> error
when its argument is <B>nil</B>.
This function is equivalent to the following Lua function:
<PRE>
      function assert (v, m)
        if not v then
          m = m or ""
          error("assertion failed!  " .. m)
        end
      end
</PRE>
<P>
<A NAME="pdf-error"></A>
<h3> <TT>error (message)</TT></h3><A NAME="error"></A>
Calls the error handler and then terminates
the last protected function called
(in&nbsp;C: <CODE>lua_dofile</CODE>, <CODE>lua_dostring</CODE>,
<CODE>lua_dobuffer</CODE>, or <CODE>lua_callfunction</CODE>;
in Lua: <CODE>dofile</CODE>, <CODE>dostring</CODE>, or <CODE>call</CODE> in protected mode).
If <CODE>message</CODE> is <B>nil</B>, the error handler is not called.
Function <CODE>error</CODE> never returns.
<CODE>error</CODE> is equivalent to the API function <CODE>lua_error</CODE>.
<P>
<h3> <TT>rawgettable (table, index)</TT></h3><A NAME="rawgettable"></A>
Gets the real value of <CODE>table[index]</CODE>,
without invoking any tag method.
<CODE>table</CODE> must be a table,
and <CODE>index</CODE> is any value different from <B>nil</B>.
<P>
<h3> <TT>rawsettable (table, index, value)</TT></h3><A NAME="rawsettable"></A>
Sets the real value of <CODE>table[index]</CODE> to <CODE>value</CODE>,
without invoking any tag method.
<CODE>table</CODE> must be a table,
<CODE>index</CODE> is any value different from <B>nil</B>,
and <CODE>value</CODE> is any Lua value.
<P>
<h3> <TT>rawsetglobal (name, value)</TT></h3><A NAME="rawsetglobal"></A>
Assigns the given value to a global variable.
The string <CODE>name</CODE> does not need to be a
syntactically valid variable name.
Therefore,
this function can set global variables with strange names like
<CODE>"m v 1"</CODE> or <CODE>34</CODE>.
<P>
<h3> <TT>setglobal (name, value)</TT></h3><A NAME="setglobal"></A>
Assigns the given value to a global variable,
or calls a tag method.
Its full semantics is explained in Section&nbsp;<A HREF="#tag-method">4.8</A>.
The string <CODE>name</CODE> does not need to be a
syntactically valid variable name.
<P>
<h3> <TT>rawgetglobal (name)</TT></h3><A NAME="rawgetglobal"></A>
Retrieves the value of a global variable.
The string <CODE>name</CODE> does not need to be a
syntactically valid variable name.
<P>
<h3> <TT>getglobal (name)</TT></h3><A NAME="getglobal"></A>
Retrieves the value of a global variable,
or calls a tag method.
Its full semantics is explained in Section&nbsp;<A HREF="#tag-method">4.8</A>.
The string <CODE>name</CODE> does not need to be a
syntactically valid variable name.
<P>
<h3> <TT>settagmethod (tag, event, newmethod)</TT></h3>
<A NAME="settagmethod"></A>
Sets a new tag method to the given pair <EM>(tag, event)</EM>.
It returns the old method.
If <CODE>newmethod</CODE> is <B>nil</B>,
<CODE>settagmethod</CODE> restores the default behavior for the given event.
<P>
<h3> <TT>gettagmethod (tag, event)</TT></h3>
<A NAME="gettagmethod"></A>
Returns the current tag method
for a given pair <EM>(tag, event)</EM>.
<P>
<h3> <TT>copytagmethods (tagto, tagfrom)</TT></h3>
<A NAME="copytagmethods"></A>
Copies all tag methods from one tag to another;
it returns <CODE>tagto</CODE>.
<P>
<A NAME="getn"></A>
<h3> <TT>getn (table)</TT></h3><A NAME="getn"></A>
Returns the ``size'' of a table, when seen as a list.
If the table has an <CODE>n</CODE> field with a numeric value,
this is its ``size''.
Otherwise, the size is the largest numerical index with a non-nil
value in the table.
This function could be defined in Lua:
<PRE>
      function getn (t)
        if type(t.n) == 'number' then return t.n end
        local max, i = 0, nil
        while 1 do
          i = next(t, i)
          if not i then break end
          if type(i) == 'number' and i&gt;max then max=i end
        end
        return max
      end
</PRE>
<P>
<P>
<h3> <TT>foreach (table, function)</TT></h3><A NAME="foreach"></A>
Executes the given <CODE>function</CODE> over all elements of <CODE>table</CODE>.
For each element, the function is called with the index and
respective value as arguments.
If the function returns any non-<B>nil</B> value,
the loop is broken, and the value is returned
as the final value of <CODE>foreach</CODE>.
<P>
This function could be defined in Lua:
<PRE>
      function foreach (t, f)
        local i, v = nil
        while 1 do
          i, v = next(t, i)
          if not i then break end
          local res = f(i, v)
          if res then return res end
        end
      end
</PRE>
<P>
If you create new indices in a table while
traversing it,
the semantics of <CODE>foreach</CODE> is undefined.
<P>
<P>
<h3> <TT>foreachi (table, function)</TT></h3><A NAME="foreachi"></A>
Executes the given <CODE>function</CODE> over the
numerical indices of <CODE>table</CODE>.
For each index, the function is called with the index and
respective value as arguments.
Indices are visited in sequential order,
from 1 to <CODE>n</CODE>,
where <CODE>n</CODE> is the result of <CODE>getn(table)</CODE> (see Section&nbsp;<A HREF="#getn">6.1</A>).
If the function returns any non-<B>nil</B> value,
the loop is broken, and the value is returned
as the final value of <CODE>foreachi</CODE>.
<P>
This function could be defined in Lua:
<PRE>
      function foreachi (t, f)
        for i=1,getn(t) do
          local res = f(i, t[i])
          if res then return res end
        end
      end
</PRE>
<P>
<h3> <TT>foreachvar (function)</TT></h3><A NAME="foreachvar"></A>
Executes <CODE>function</CODE> over all global variables.
For each variable,
the function is called with its name and its value as arguments.
If the function returns any non-nil value,
the loop is broken, and the value is returned
as the final value of <CODE>foreachvar</CODE>.
<P>
This function could be defined in Lua:
<PRE>
      function foreachvar (f)
        local n, v = nil
        while 1 do
          n, v = nextvar(n)
          if not n then break end
          local res = f(n, v)
          if res then return res end
        end
      end
</PRE>
<P>
If you create new global variables during the traversal,
the semantics of <CODE>foreachvar</CODE> is undefined.
<P>
<h3> <TT>tinsert (table [, pos] , value)</TT></h3><A NAME="tinsert"></A>
<P>
Inserts element <CODE>value</CODE> at table position <CODE>pos</CODE>,
shifting other elements to open space, if necessary.
The default value for <CODE>pos</CODE> is <CODE>n+1</CODE>,
where <CODE>n</CODE> is the result of <CODE>getn(table)</CODE> (see Section&nbsp;<A HREF="#getn">6.1</A>),
so that a call <CODE>tinsert(t,x)</CODE> inserts <CODE>x</CODE> at the end
of table <CODE>t</CODE>.
<P>
This function also sets or increments the field <CODE>n</CODE> of the table,
to <CODE>n+1</CODE>.
<P>
This function is equivalent to the following Lua function,
except that the table accesses are all raw (that is, without tag methods):
<PRE>
      function tinsert (t, ...)
        local pos, value
        local n = getn(t)
        if arg.n == 1 then
          pos, value = n+1, arg[1]
        else
          pos, value = arg[1], arg[2]
        end
        t.n = n+1;
        for i=n,pos,-1 do
          t[i+1] = t[i]
        end
        t[pos] = value
      end
</PRE>
<P>
<h3> <TT>tremove (table [, pos])</TT></h3><A NAME="tremove"></A>
<P>
Removes from <CODE>table</CODE> the element at position <CODE>pos</CODE>,
shifting other elements to close the space, if necessary.
Returns the value of the removed element.
The default value for <CODE>pos</CODE> is <CODE>n</CODE>
(where <CODE>n</CODE> is the result of <CODE>getn(table)</CODE> (see Section&nbsp;<A HREF="#getn">6.1</A>)),
so that a call <CODE>tremove(t)</CODE> removes the last element
of table <CODE>t</CODE>.
<P>
This function also sets or decrements the field <CODE>n</CODE> of the table,
to <CODE>n-1</CODE>.
<P>
This function is equivalent to the following Lua function,
except that the table accesses are all raw (that is, without tag methods):
<PRE>
      function tremove (t, pos)
        local n = getn(t)
        if n&lt;=0 then return end
        pos = pos or n
        local value = t[pos]
        for i=pos,n-1 do
          t[i] = t[i+1]
        end
        t[n] = nil
        t.n = n-1
        return value
      end
</PRE>
<P>
<h3> <TT>sort (table [, comp])</TT></h3><A NAME="sort"></A>
Sorts table elements in a given order, <EM>in-place</EM>,
from <CODE>table[1]</CODE> to <CODE>table[n]</CODE>,
where <CODE>n</CODE> is the result of <CODE>getn(table)</CODE> (see Section&nbsp;<A HREF="#getn">6.1</A>).
If <CODE>comp</CODE> is given,
it must be a function that receives two table elements,
and returns true when the first is less than the second
(so that <CODE>not comp(a[i+1], a[i])</CODE> will be true after the sort).
If <CODE>comp</CODE> is not given,
the standard Lua operator <CODE>&lt;</CODE> is used instead.
<P>
<P>
<A NAME="6.2"></A>
<H2>6.2 - String Manipulation</H2>
This library provides generic functions for string manipulation,
such as finding and extracting substrings and pattern matching.
When indexing a string, the first character is at position&nbsp;1
(not at&nbsp;0, as in C).
<P>
<h3> <TT>strfind (str, pattern [, init [, plain]])</TT></h3>
<A NAME="strfind"></A>
Looks for the first <EM>match</EM> of
<CODE>pattern</CODE> in <CODE>str</CODE>.
If it finds one, then it returns the indices on <CODE>str</CODE>
where this occurrence starts and ends;
otherwise, it returns <B>nil</B>.
If the pattern specifies captures,
the captured strings are returned as extra results.
A third optional numerical argument specifies where to start the search;
its default value is 1.
If <CODE>init</CODE> is negative,
it is replaced by the length of the string minus its
absolute value plus 1.
Therefore, <I>-1</I> points to the last character of <CODE>str</CODE>.
A value of 1 as a fourth optional argument
turns off the pattern matching facilities,
so the function does a plain ``find substring'' operation,
with no characters in <CODE>pattern</CODE> being considered ``magic''.
<P>
<h3> <TT>strlen (s)</TT></h3><A NAME="strlen"></A>
Receives a string and returns its length.
<P>
<h3> <TT>strsub (s, i [, j])</TT></h3><A NAME="strsub"></A>
Returns another string, which is a substring of <CODE>s</CODE>,
starting at <CODE>i</CODE>  and running until <CODE>j</CODE>.
If <CODE>i</CODE> or <CODE>j</CODE> are negative,
they are replaced by the length of the string minus their
absolute value plus 1.
Therefore, <I>-1</I> points to the last character of <CODE>s</CODE>
and <I>-2</I> to the previous one.
If <CODE>j</CODE> is absent, it is assumed to be equal to <I>-1</I>
(which is the same as the string length).
In particular,
the call <CODE>strsub(s,1,j)</CODE> returns a prefix of <CODE>s</CODE>
with length <CODE>j</CODE>,
and the call <CODE>strsub(s, -i)</CODE> returns a suffix of <CODE>s</CODE>
with length <CODE>i</CODE>.
<P>
<h3> <TT>strlower (s)</TT></h3><A NAME="strlower"></A>
Receives a string and returns a copy of that string with all
upper case letters changed to lower case.
All other characters are left unchanged.
The definition of what is an upper case
letter depends on the current locale.
<P>
<h3> <TT>strupper (s)</TT></h3><A NAME="strupper"></A>
Receives a string and returns a copy of that string with all
lower case letters changed to upper case.
All other characters are left unchanged.
The definition of what is a lower case
letter depends on the current locale.
<P>
<h3> <TT>strrep (s, n)</TT></h3><A NAME="strrep"></A>
Returns a string that is the concatenation of <CODE>n</CODE> copies of
the string <CODE>s</CODE>.
<P>
<h3> <TT>strbyte (s [, i])</TT></h3><A NAME="strbyte"></A>
Returns the internal numerical code of the character <CODE>s[i]</CODE>.
If <CODE>i</CODE> is absent, then it is assumed to be 1.
If <CODE>i</CODE> is negative,
it is replaced by the length of the string minus its
absolute value plus 1.
Therefore, <I>-1</I> points to the last character of <CODE>s</CODE>.
<P>
Note that numerical codes are not necessarily portable across platforms.
<P>
<h3> <TT>strchar (i1, i2, ...)</TT></h3><A NAME="strchar"></A>
Receives 0 or more integers.
Returns a string with length equal to the number of arguments,
wherein each character has the internal numerical code equal
to its correspondent argument.
<P>
Note that numerical codes are not necessarily portable across platforms.
<P>
<h3> <TT>format (formatstring, e1, e2, ...)</TT></h3><A NAME="format"></A>
<A NAME="format"></A>

Returns a formatted version of its variable number of arguments
following the description given in its first argument (which must be a string).
The format string follows the same rules as the <CODE>printf</CODE> family of
standard C functions.
The only differences are that the options/modifiers
<CODE>*</CODE>, <CODE>l</CODE>, <CODE>L</CODE>, <CODE>n</CODE>, <CODE>p</CODE>,
and <CODE>h</CODE> are not supported,
and there is an extra option, <CODE>q</CODE>.
This option formats a string in a form suitable to be safely read
back by the Lua interpreter:
The string is written between double quotes,
and all double quotes, returns and backslashes in the string
are correctly escaped when written.
For instance, the call
<PRE>
format('%q', 'a string with "quotes" and \n new line')
</PRE>
will produce the string:
<PRE>
"a string with \"quotes\" and \
 new line"
</PRE>
<P>
Conversions can be applied to the n-th argument in the argument list,
rather than the next unused argument.
In this case, the conversion character <CODE>%</CODE> is replaced
by the sequence <CODE>%d$</CODE>, where <CODE>d</CODE> is a
decimal digit in the range [1,9],
giving the position of the argument in the argument list.
For instance, the call <CODE>format("%2$d -&gt; %1$03d", 1, 34)</CODE> will
result in <CODE>"34 -&gt; 001"</CODE>.
The same argument can be used in more than one conversion.
<P>
The options <CODE>c</CODE>, <CODE>d</CODE>, <CODE>E</CODE>, <CODE>e</CODE>, <CODE>f</CODE>,
<CODE>g</CODE>, <CODE>G</CODE>, <CODE>i</CODE>, <CODE>o</CODE>, <CODE>u</CODE>, <CODE>X</CODE>, and <CODE>x</CODE> all
expect a number as argument,
whereas <CODE>q</CODE> and <CODE>s</CODE> expect a string.
The <CODE>*</CODE> modifier can be simulated by building
the appropriate format string.
For example, <CODE>"%*g"</CODE> can be simulated with
<CODE>"%"..width.."g"</CODE>.
<P>
\emph{Note: function <TT>format</TT> can only be used with strings that do not
contain zeros (0).}
<P>
<h3> <TT>gsub (s, pat, repl [, n])</TT></h3>
<A NAME="gsub"></A>
Returns a copy of <CODE>s</CODE>,
where all occurrences of the pattern <CODE>pat</CODE> have been
replaced by a replacement string specified by <CODE>repl</CODE>.
This function also returns, as a second value,
the total number of substitutions made.
<P>
If <CODE>repl</CODE> is a string, then its value is used for replacement.
Any sequence in <CODE>repl</CODE> of the form <CODE>%n</CODE>
with <CODE>n</CODE> between 1 and 9
stands for the value of the n-th captured substring.
<P>
If <CODE>repl</CODE> is a function, then this function is called every time a
match occurs, with all captured substrings passed as arguments,
in order (see below).
If the value returned by this function is a string,
then it is used as the replacement string;
otherwise, the replacement string is the empty string.
<P>
A last optional parameter <CODE>n</CODE> limits
the maximum number of substitutions to occur.
For instance, when <CODE>n</CODE> is 1 only the first occurrence of
<CODE>pat</CODE> is replaced.
<P>
Here are some examples:
<PRE>
  x = gsub("hello world", "(%w+)", "%1 %1")
  --&gt; x="hello hello world world"
<P>
  x = gsub("hello world", "(%w+)", "%1 %1", 1)
  --&gt; x="hello hello world"
<P>
  x = gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
  --&gt; x="world hello Lua from"
<P>
  x = gsub("home = $HOME, user = $USER", "%$(%w+)", getenv)
  --&gt; x="home = /home/roberto, user = roberto"  (for instance)
<P>
  x = gsub("4+5 = $return 4+5$", "%$(.-)%$", dostring)
  --&gt; x="4+5 = 9"
<P>
  local t = {name="lua", version="3.2"}
  x = gsub("$name - $version", "%$(%w+)", function (v) return %t[v] end)
  --&gt; x="lua - 3.2"
<P>
  t = {n=0}
  gsub("first second word", "(%w+)", function (w) tinsert(%t, w) end)
  --&gt; t={"first", "second", "word"; n=3}
</PRE>
<P>
<P>
<A NAME="pm"></A>
<h3>Patterns</h3> 
<P>
<H4>Character Class:</H4>
a <A NAME="character class"><EM>character class</EM></A> is used to represent a set of characters.
The following combinations are allowed in describing a character class:
<DL>
<DT><B><EM>x</EM></B><DD> (where <EM>x</EM> is any character not in the list
<CODE>^$()%.[]*+-?</CODE>)
- represents the character <EM>x</EM> itself.
<DT><B><TT>.</TT></B><DD> - (a dot) represents all characters.
<DT><B><TT>%a</TT></B><DD> - represents all letters.
<DT><B><TT>%c</TT></B><DD> - represents all control characters.
<DT><B><TT>%d</TT></B><DD> - represents all digits.
<DT><B><TT>%l</TT></B><DD> - represents all lower case letters.
<DT><B><TT>%p</TT></B><DD> - represents all punctuation characters.
<DT><B><TT>%s</TT></B><DD> - represents all space characters.
<DT><B><TT>%u</TT></B><DD> - represents all upper case letters.
<DT><B><TT>%w</TT></B><DD> - represents all alphanumeric characters.
<DT><B><TT>%x</TT></B><DD> - represents all hexadecimal digits.
<DT><B><TT>%z</TT></B><DD> - represents the character with representation 0.
<DT><B><TT>%<EM>x</TT></EM></B><DD> (where <EM>x</EM> is any non alphanumeric character)  -
represents the character <EM>x</EM>.
This is the standard way to escape the magic characters <CODE>()%.[]*-?</CODE>.
It is strongly recommended that any control character (even the non magic),
when used to represent itself in a pattern, should be preceded by a <CODE>%</CODE>.
<P>
<DT><B><TT>[char-set</TT></B>]<DD> -
Represents the class which is the union of all
characters in char-set.
A range of characters may be specified by
separating the end characters of the range with a <CODE>-</CODE>.
All classes <CODE>%</CODE><EM>x</EM> described above can also be used as
components in a char-set.
All other characters in char-set represent themselves.
E.g., <CODE>[%w_]</CODE> (or <CODE>[_%w]</CODE>)
represents all alphanumeric characters plus the underscore,
<CODE>[0-7]</CODE> represents the octal digits,
and <CODE>[0-7%l%-]</CODE> represents the octal digits plus
the lower case letters plus the <CODE>-</CODE> character.
<P>
The interaction between ranges and classes is not defined.
Therefore, patterns like <CODE>[%a-z]</CODE> or <CODE>[a-%%]</CODE>
have no meaning.
<P>
<DT><B><TT>[^char-set</TT></B>]<DD> -
represents the complement of char-set,
where char-set is interpreted as above.
</DL>
For all classes represented by single letters (<CODE>%a</CODE>, <CODE>%c</CODE>, ...),
the correspondent upper-case letter represents the complement of the class.
For instance, <CODE>%S</CODE> represents all non-space characters.
<P>
The definitions of letter, space, etc. depend on the current locale.
In particular, the class <CODE>[a-z]</CODE> may not be equivalent to <CODE>%l</CODE>.
The second form should be preferred for portability.
<P>
<H4>Pattern Item:</H4>
a <A NAME="pattern item"><EM>pattern item</EM></A> may be
<UL>
<LI>
a single character class,
which matches any single character in the class;
<LI>
a single character class followed by <CODE>*</CODE>,
which matches 0 or more repetitions of characters in the class.
These repetition items will always match the longest possible sequence;
<LI>
a single character class followed by <CODE>+</CODE>,
which matches 1 or more repetitions of characters in the class.
These repetition items will always match the longest possible sequence;
<LI>
a single character class followed by <CODE>-</CODE>,
which also matches 0 or more repetitions of characters in the class.
Unlike <CODE>*</CODE>,
these repetition items will always match the shortest possible sequence;
<LI>
a single character class followed by <CODE>?</CODE>,
which matches 0 or 1 occurrence of a character in the class;
<LI>
<TT>%<EM>n</TT></EM>, for <EM>n</EM> between 1 and 9;
such item matches a sub-string equal to the n-th captured string
(see below);
<LI>
<TT>%b<EM>xy</TT></EM>, where <EM>x</EM> and <EM>y</EM> are two distinct characters;
such item matches strings that start with <EM>x</EM>, end with <EM>y</EM>,
and where the <EM>x</EM> and <EM>y</EM> are <EM>balanced</EM>.
That means that, if one reads the string from left to write,
counting plus 1 for an <EM>x</EM> and minus 1 for a <EM>y</EM>,
the ending <EM>y</EM> is the first where the count reaches 0.
For instance, the item <CODE>%b()</CODE> matches expressions with
balanced parentheses.
</UL>
<P>
<H4>Pattern:</H4>
a <A NAME="pattern"><EM>pattern</EM></A> is a sequence of pattern items.
A <CODE>^</CODE> at the beginning of a pattern anchors the match at the
beginning of the subject string.
A <CODE>$</CODE> at the end of a pattern anchors the match at the
end of the subject string.
<P>
<H4>Captures:</H4>
a pattern may contain sub-patterns enclosed in parentheses,
that describe <A NAME="captures"><EM>captures</EM></A>.
When a match succeeds, the sub-strings of the subject string
that match captures are stored (<EM>captured</EM>) for future use.
Captures are numbered according to their left parentheses.
For instance, in the pattern <CODE>"(a*(.)%w(%s*))"</CODE>,
the part of the string matching <CODE>"a*(.)%w(%s*)"</CODE> is
stored as the first capture (and therefore has number&nbsp;1);
the character matching <CODE>.</CODE> is captured with number&nbsp;2,
and the part matching <CODE>%s*</CODE> has number&nbsp;3.
<P>
<EM>Note: A pattern cannot contain zeros (<CODE>'\0'</CODE>).  Use <CODE>'%z'</CODE> instead.</EM>
<P>
<P>
<A NAME="mathlib"></A>
<A NAME="6.3"></A>
<H2>6.3 - Mathematical Functions</H2> 
<P>
This library is an interface to some functions of the standard C math library.
In addition, it registers a tag method for the binary operator <CODE>^</CODE> that
returns <I>x^y</I> when applied to numbers <CODE>x^y</CODE>.
<P>
The library provides the following functions:
<A NAME="abs"></A><A NAME="acos"></A><A NAME="asin"></A><A NAME="atan"></A>
<A NAME="atan2"></A><A NAME="ceil"></A><A NAME="cos"></A><A NAME="floor"></A>
<A NAME="log"></A><A NAME="log10"></A><A NAME="max"></A><A NAME="min"></A>
<A NAME="mod"></A><A NAME="sin"></A><A NAME="sqrt"></A><A NAME="tan"></A>
<A NAME="frexp"></A><A NAME="ldexp"></A>
<A NAME="random"></A><A NAME="randomseed"></A>
<PRE>
abs acos asin atan atan2 ceil cos deg   floor log log10
max min  mod  rad  sin   sqrt tan frexp ldexp
random   randomseed
</PRE>
plus a global variable <A NAME="PI"><TT>PI</TT></A>.
Most of them
are only interfaces to the homonymous functions in the C library,
except that, for the trigonometric functions,
all angles are expressed in <EM>degrees</EM>, not radians.
Functions <A NAME="deg"><TT>deg</TT></A> and <A NAME="rad"><TT>rad</TT></A> can be used to convert
between radians and degrees.
<P>
The function <CODE>max</CODE> returns the maximum
value of its numeric arguments.
Similarly, <CODE>min</CODE> computes the minimum.
Both can be used with 1, 2 or more arguments.
<P>
The functions <CODE>random</CODE> and <CODE>randomseed</CODE> are interfaces to
the simple random generator functions <CODE>rand</CODE> and <CODE>srand</CODE>,
provided by ANSI C.
The function <CODE>random</CODE>, when called without arguments,
returns a pseudo-random real number in the range <I>[0,1)</I>.
When called with a number <I>n</I>,
<CODE>random</CODE> returns a pseudo-random integer in the range <I>[1,n]</I>.
When called with two arguments, <I>l</I> and <I>u</I>,
<CODE>random</CODE> returns a pseudo-random integer in the range <I>[l,u]</I>.
<P>
<P>
<A NAME="libio"></A>
<A NAME="6.4"></A>
<H2>6.4 - I/O Facilities</H2> 
<P>
All input and output operations in Lua are done, by default,
over two <A NAME="file handles"><EM>file handles</EM></A>, one for reading and one for writing.
These handles are stored in two Lua global variables,
called <CODE>_INPUT</CODE> and <CODE>_OUTPUT</CODE>.
The global variables
<CODE>_STDIN</CODE>, <CODE>_STDOUT</CODE> and <CODE>_STDERR</CODE>
are initialized with file descriptors for
<CODE>stdin</CODE>, <CODE>stdout</CODE> and <CODE>stderr</CODE>.
Initially, <CODE>_INPUT=_STDIN</CODE> and <CODE>_OUTPUT=_STDOUT</CODE>.
<A NAME="_INPUT"></A><A NAME="_OUTPUT"></A>
<A NAME="_STDIN"></A><A NAME="_STDOUT"></A><A NAME="_STDERR"></A>
<P>
A file handle is a userdata containing the file stream <CODE>FILE*</CODE>,
and with a distinctive tag created by the I/O library.
<P>
Unless otherwise stated,
all I/O functions return <B>nil</B> on failure and
some value different from <B>nil</B> on success.
<P>
<h3> <TT>openfile (filename, mode)</TT></h3><A NAME="openfile"></A>
<P>
This function opens a file,
in the mode specified in the string <CODE>mode</CODE>.
It returns a new file handle,
or, in case of errors, <B>nil</B> plus a string describing the error.
This function does not modify either <CODE>_INPUT</CODE> or <CODE>_OUTPUT</CODE>.
<P>
The string mode can be any of the following:
<DL>
<DT><B>``r''</B><DD> read mode;
<DT><B>``w''</B><DD> write mode;
<DT><B>``a''</B><DD> append mode;
<DT><B>``r+''</B><DD> update mode, all previous data is preserved;
<DT><B>``w+''</B><DD> update mode, all previous data is erased;
<DT><B>``a+''</B><DD> append update mode, previous data is preserved,
  writing is only allowed at the end of file.
</DL>
The string mode may also have a <CODE>b</CODE> at the end,
which is needed in some systems to open the file in binary mode.
<P>
<h3> <TT>closefile (handle)</TT></h3><A NAME="closefile"></A>
<P>
This function closes the given file.
It does not modify either <CODE>_INPUT</CODE> or <CODE>_OUTPUT</CODE>.
<P>
<h3> <TT>readfrom (filename)</TT></h3><A NAME="readfrom"></A>
<P>
This function may be called in two ways.
When called with a file name, it opens the named file,
sets its handle as the value of <CODE>_INPUT</CODE>,
and returns this value.
It does not close the current input file.
When called without parameters,
it closes the <CODE>_INPUT</CODE> file,
and restores <CODE>stdin</CODE> as the value of <CODE>_INPUT</CODE>.
<P>
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<CITE>
<EM>System dependent</EM>: if <CODE>filename</CODE> starts with a <CODE>|</CODE>,
then a <A NAME="piped input">piped input</A> is opened, via function <A NAME="popen"><TT>popen</TT></A>.
Not all systems implement pipes.
Moreover,
the number of files that can be open at the same time is
usually limited and depends on the system.
</CITE>
<P>
<h3> <TT>writeto (filename)</TT></h3><A NAME="writeto"></A>
<P>
This function may be called in two ways.
When called with a file name,
it opens the named file,
sets its handle as the value of <CODE>_OUTPUT</CODE>,
and returns this value.
It does not close the current output file.
Note that, if the file already exists,
then it will be <EM>completely erased</EM> with this operation.
When called without parameters,
this function closes the <CODE>_OUTPUT</CODE> file,
and restores <CODE>stdout</CODE> as the value of <CODE>_OUTPUT</CODE>.
<A NAME="closing a file"></A>
<P>
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<CITE>
<EM>System dependent</EM>: if <CODE>filename</CODE> starts with a <CODE>|</CODE>,
then a <A NAME="piped output">piped output</A> is opened, via function <A NAME="popen"><TT>popen</TT></A>.
Not all systems implement pipes.
Moreover,
the number of files that can be open at the same time is
usually limited and depends on the system.
</CITE>
<P>
<h3> <TT>appendto (filename)</TT></h3><A NAME="appendto"></A>
<P>
Opens a file named <CODE>filename</CODE> and sets it as the
value of <CODE>_OUTPUT</CODE>.
Unlike the <CODE>writeto</CODE> operation,
this function does not erase any previous contents of the file.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3> <TT>remove (filename)</TT></h3><A NAME="remove"></A>
<P>
Deletes the file with the given name.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3> <TT>rename (name1, name2)</TT></h3><A NAME="rename"></A>
<P>
Renames file named <CODE>name1</CODE> to <CODE>name2</CODE>.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3> <TT>flush ([filehandle])</TT></h3><A NAME="flush"></A>
<P>
Saves any written data to the given file.
If <CODE>filehandle</CODE> is not specified,
flushes all open files.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3> <TT>seek (filehandle [, whence] [, offset])</TT></h3><A NAME="seek"></A>
<P>
Sets and gets the file position,
measured in bytes from the beginning of the file,
to the position given by <CODE>offset</CODE> plus a base
specified by the string <CODE>whence</CODE>, as follows:
<DL>
<DT><B>``set''</B><DD> base is position 0 (beginning of the file);
<DT><B>``cur''</B><DD> base is current position;
<DT><B>``end''</B><DD> base is end of file;
</DL>
In case of success, function <CODE>seek</CODE> returns the final file position,
measured in bytes from the beginning of the file.
If the call fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
The default value for <CODE>whence</CODE> is <CODE>"cur"</CODE>,
and for <CODE>offset</CODE> is 0.
Therefore, the call <CODE>seek(file)</CODE> returns the current
file position, without changing it;
the call <CODE>seek(file, "set")</CODE> sets the position to the
beginning of the file (and returns 0);
and the call <CODE>seek(file, "end")</CODE> sets the position to the
end of the file, and returns its size.
<P>
<h3> <TT>tmpname ()</TT></h3><A NAME="tmpname"></A>
<P>
Returns a string with a file name that can safely
be used for a temporary file.
The file must be explicitly opened before its use
and removed when no longer needed.
<P>
<h3> <TT>read ([filehandle,] format1, ...)</TT></h3><A NAME="read"></A>
<P>
Reads file <CODE>_INPUT</CODE>,
or <CODE>filehandle</CODE> if this argument is given,
according to the given formats, which specify what to read.
For each format,
the function returns a string (or a number) with the characters read,
or <B>nil</B> if it cannot read data with the specified format.
When called without patterns,
it uses a default format that reads the next line
(see below).
<P>
The available formats are
<DL>
<DT><B>``*n''</B><DD> reads a number;
this is the only format that returns a number instead of a string.
<DT><B>``*l''</B><DD> reads the next line
(skipping the end of line), or <B>nil</B> on end of file.
This is the default format.
<DT><B>``*a''</B><DD> reads the whole file, starting at the current position.
On end of file, it returns the empty string.
<DT><B>``*w''</B><DD> reads the next word
(maximal sequence of non white-space characters),
skipping spaces if necessary, or <B>nil</B> on end of file.
</DL>
<P>
<h3> <TT>write ([filehandle, ] value1, ...)</TT></h3><A NAME="write"></A>
<P>
Writes the value of each of its arguments to
file <CODE>_OUTPUT</CODE>,
or to <CODE>filehandle</CODE> if this argument is given.
The arguments must be strings or numbers.
To write other values,
use <CODE>tostring</CODE> or <CODE>format</CODE> before <CODE>write</CODE>.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3> <TT>date ([format])</TT></h3><A NAME="date"></A>
<P>
Returns a string containing date and time
formatted according to the given string <CODE>format</CODE>,
following the same rules of the ANSI C function <CODE>strftime</CODE>.
When called without arguments,
it returns a reasonable date and time representation that depends on
the host system and on the current locale.
<P>
<h3> <TT>clock ()</TT></h3><A NAME="clock"></A>
<P>
Returns an approximation of the amount of CPU time
used by the program, in seconds.
<P>
<h3> <TT>exit ([code])</TT></h3><A NAME="exit"></A>
<P>
Calls the C function <CODE>exit</CODE>,
with an optional <CODE>code</CODE>,
to terminate the program.
The default value for <CODE>code</CODE> is the success code.
<P>
<h3> <TT>getenv (varname)</TT></h3><A NAME="getenv"></A>
<P>
Returns the value of the process environment variable <CODE>varname</CODE>,
or <B>nil</B> if the variable is not defined.
<P>
<h3> <TT>execute (command)</TT></h3><A NAME="execute"></A>
<P>
This function is equivalent to the C function <CODE>system</CODE>.
It passes <CODE>command</CODE> to be executed by an operating system shell.
It returns a status code, which is system-dependent.
<P>
<h3> <TT>setlocale (locale [, category])</TT></h3><A NAME="setlocale"></A>
<P>
This function is an interface to the ANSI C function <CODE>setlocale</CODE>.
<CODE>locale</CODE> is a string specifying a locale;
<CODE>category</CODE> is an optional string describing which category to change:
<CODE>"all"</CODE>, <CODE>"collate"</CODE>, <CODE>"ctype"</CODE>,
<CODE>"monetary"</CODE>, <CODE>"numeric"</CODE>, or <CODE>"time"</CODE>;
the default category is <CODE>"all"</CODE>.
The function returns the name of the new locale,
or <B>nil</B> if the request cannot be honored.
<P>
<P>
<A NAME="debugI"></A>
<!-- ====================================================================== -->
<HR>
<A NAME="7."></A>
<H1>7 - The Debugger Interface</H1> 
<P>
Lua has no built-in debugging facilities.
Instead, it offers a special interface,
by means of functions and <EM>hooks</EM>,
which allows the construction of different
kinds of debuggers, profilers, and other tools
that need ``inside information'' from the interpreter.
This interface is declared in the header file <CODE>luadebug.h</CODE>.
<P>
<A NAME="7.1"></A>
<H2>7.1 - Stack and Function Information</H2>
<P>
<A NAME="lua_getstack"></A>
The main function to get information about the interpreter stack is
<PRE>
int lua_getstack (lua_State *L, int level, lua_Debug *ar);
</PRE>
It fills parts of a structure (<CODE>lua_Debug</CODE>) with
an identification of the <EM>activation record</EM>
of the function executing at a given level.
Level&nbsp;0 is the current running function,
while level <I>n+1</I> is the function that has called level <I>n</I>.
Usually, <CODE>lua_getstack</CODE> returns 1;
when called with a level greater than the stack depth,
it returns 0.
<P>
The structure <CODE>lua_Debug</CODE> is used to carry different informations
about an active function: <A NAME="lua_Debug"></A>
<PRE>
struct lua_Debug {
  const char *event;     /* `call', `return' */
  const char *source;    /* (S) */
  int linedefined;       /* (S) */
  const char *what;      /* (S) `Lua' function, `C' function, Lua `main' */
  int currentline;       /* (l) */
  const char *name;      /* (n) */
  const char *namewhat;  /* (n) global, tag method, local, field */
  int nups;              /* (u) number of upvalues */
  lua_Object func;       /* (f) function being executed */
  /* private part */
  ...
};
</PRE>
The <CODE>lua_getstack</CODE> function fills only the private part
of this structure, for future use.
To fill in the other fields of <CODE>lua_Debug</CODE> with useful information,
you call <A NAME="lua_getinfo"></A>
<PRE>
int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
</PRE>
Each character in string <CODE>what</CODE> selects some fields to be filled,
as indicated by the letter in parentheses in the structure definition;
that is, an <CODE>S</CODE> fills the fields <CODE>source</CODE> and <CODE>linedefined</CODE>,
and <CODE>l</CODE> fills the field <CODE>currentline</CODE>, etc.
Next we describe each field:
<DL>
<P>
<DT><B>source</B><DD>
If the function was defined in a string,
<CODE>source</CODE> is that string;
if the function was defined in a file,
<CODE>source</CODE> starts with a <CODE>@</CODE> followed by the file name.
<P>
<DT><B>linedefined</B><DD>
the line number where starts the definition of the function.
<P>
<DT><B>what</B><DD> the string <CODE>"Lua"</CODE> if this is a Lua function,
<CODE>"C"</CODE> if this is a C function,
or <CODE>"main"</CODE> if this is the main part of a chunk.
<P>
<DT><B>currentline</B><DD>
the current line where the given function is executing.
It only works if the function has been compiled with debug
information.
When no line information is available,
<CODE>currentline</CODE> is set to <I>-1</I>.
<P>
<DT><B>name</B><DD>
a reasonable name for the given function.
Because functions in Lua are first class values,
they do not have a fixed name:
Some functions may be the value of many global variables,
while others may be stored only in a table field.
The <CODE>lua_getinfo</CODE> function checks whether the given
function is a tag method or the value of a global variable.
If the given function is a tag method,
<CODE>name</CODE> points to the event name.
If the given function is the value of a global variable,
<CODE>name</CODE> points to the variable name.
If the given function is neither a tag method nor a global variable,
<CODE>name</CODE> is set to <CODE>NULL</CODE>.
<P>
<DT><B>namewhat</B><DD>
Explains the previous field.
If the function is a global variable,
<CODE>namewhat</CODE> is <CODE>"global"</CODE>;
if the function is a tag method,
<CODE>namewhat</CODE> is <CODE>"tag-method"</CODE>;
otherwise <CODE>namewhat</CODE> is <CODE>""</CODE> (the empty string).
<P>
<DT><B>nups</B><DD>
Number of upvalues of a C function.
If the function is not a C function,
<CODE>nups</CODE> is set to 0.
<P>
<DT><B>func</B><DD>
The function being executed, as a <CODE>lua_Object</CODE>.
<P>
</DL>
<P>
The generation of debug information is controlled by an internal flag,
which can be switched with
<PRE>
int lua_setdebug (lua_State *L, int debug);
</PRE>
This function sets the flag and returns its previous value.
This flag can also be set from Lua&nbsp;(see Section&nbsp;<A HREF="#pragma">4.9</A>).
<P>
<A NAME="7.2"></A>
<H2>7.2 - Manipulating Local Variables</H2>
<P>
For the manipulation of local variables,
<CODE>luadebug.h</CODE> defines the following record:
<PRE>
struct lua_Localvar {
  int index;
  const char *name;
  lua_Object value;
};
</PRE>
where <CODE>index</CODE> is an index for local variables
(the first parameter has index 1, and so on,
until the last active local variable).
<P>
<A NAME="lua_getlocal"></A><A NAME="lua_setlocal"></A>
The following functions allow the manipulation of the
local variables of a given activation record.
They only work if the function has been compiled with debug
information (see Section&nbsp;<A HREF="#pragma">4.9</A>).
For these functions, a local variable becomes
visible in the line after its definition.
<PRE>
int lua_getlocal (lua_State *L, const lua_Debug *ar, lua_Localvar *v);
int lua_setlocal (lua_State *L, const lua_Debug *ar, lua_Localvar *v);
</PRE>
The parameter <CODE>ar</CODE> must be a valid activation record,
filled by a previous call to <CODE>lua_getstack</CODE> or
given as argument to a hook (see next section).
To use <CODE>lua_getlocal</CODE>,
you fill the <CODE>index</CODE> field of <CODE>v</CODE> with the index
of a local variable; then the function fills the fields
<CODE>name</CODE> and <CODE>value</CODE> with the name and the current
value of that variable.
For <CODE>lua_setlocal</CODE>,
you fill the <CODE>index</CODE> and the <CODE>value</CODE> fields of <CODE>v</CODE>,
and the function assigns that value to the variable.
Both functions return 0 on failure, that happens
if the index is greater than the number of active local variables,
or if the activation record has no debug information.
<P>
As an example, the following function lists the names of all
local variables for a function in a given level of the stack:
<PRE>
int listvars (lua_State *L, int level) {
  lua_Debug ar;
  int i;
  if (lua_getstack(L, level, &amp;ar) == 0)
    return 0;  /* failure: no such level on the stack */
  for (i=1; ;i++) {
    lua_Localvar v;
    v.index = i;
    if (lua_getlocal(L, &amp;ar, &amp;v) == 0)
      return 1;  /* no more locals, or no debug information */
    printf("%s\n", v.name);
  }
}
</PRE>
<P>
<P>
<A NAME="7.3"></A>
<H2>7.3 - Hooks</H2>
<P>
The Lua interpreter offers two hooks for debugging purposes:
a <EM>call</EM> hook and a <EM>line</EM> hook.
Both have the same type,
<PRE>
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
</PRE>
and you can set them with the following functions:
<A NAME="lua_Hook"></A><A NAME="lua_setcallhook"></A><A NAME="lua_setlinehook"></A>
<PRE>
lua_Hook lua_setcallhook (lua_State *L, lua_Hook func);
lua_Hook lua_setlinehook (lua_State *L, lua_Hook func);
</PRE>
A hook is disabled when its value is <CODE>NULL</CODE>,
which is the initial value of both hooks.
The functions <CODE>lua_setcallhook</CODE> and <CODE>lua_setlinehook</CODE>
set their corresponding hooks and return their previous values.
<P>
The call hook is called whenever the
interpreter enters or leaves a function.
The <CODE>event</CODE> field of <CODE>ar</CODE> has the strings <CODE>"call"</CODE>
or <CODE>"return"</CODE>.
This <CODE>ar</CODE> can then be used in calls to <CODE>lua_getinfo</CODE>,
<CODE>lua_getlocal</CODE>, and <CODE>lua_setlocal</CODE>,
to get more information about the function and to manipulate its
local variables.
<P>
The line hook is called every time the interpreter changes
the line of code it is executing.
The <CODE>currentline</CODE> field of <CODE>ar</CODE> has the line number.
Again, you can use this <CODE>ar</CODE> in other calls to the API.
This hook is called only if the active function
has been compiled with debug information&nbsp;(see Section&nbsp;<A HREF="#pragma">4.9</A>).
<P>
While Lua is running a hook, it disables other calls to hooks.
Therefore, if a hook calls Lua to execute a function or a chunk,
this execution ocurrs without any calls to hooks.
<P>
A hook cannot call <TT>lua_error</TT>.
It must return to Lua through a regular return.
(There is no problem if the error is inside a chunk or a Lua function
called by the hook, because those errors are protected;
the control returns to the hook anyway.)
<P>
<P>
<A NAME="7.4"></A>
<H2>7.4 - The Reflexive Debugger Interface</H2>
<P>
The library <CODE>ldblib</CODE> provides
the functionality of the debugger interface to Lua programs.
If you want to use this library,
your host application must open it,
by calling <CODE>lua_dblibopen</CODE>.
<P>
You should exert great care when using this library.
The functions provided here should be used exclusively for debugging
and similar tasks (e.g., profiling).
Please resist the temptation to use them as a
usual programming tool.
They are slow and violate some (otherwise) secure aspects of the
language (e.g., privacy of local variables).
As a general rule, if your program does not need this library,
do not open it.
<P>
<P>
<h3> <TT>getstack (level, what)</TT></h3><A NAME="getstack"></A>
<P>
This function returns a table with informations about the function
running at level <CODE>level</CODE> of the stack.
Level 0 is the current function (<CODE>getstack</CODE> itself);
level 1 is the function that called <CODE>getstack</CODE>.
If <CODE>level</CODE> is larger than the number of active functions,
the function returns <B>nil</B>.
The table contains all the fields returned by <CODE>lua_getinfo</CODE>,
with the string <CODE>what</CODE> describing what to get.
<P>
For instance, the expression <CODE>getstack(1, 'n').name</CODE> returns
the name of the current function.
<P>
<P>
<h3> <TT>getlocal (level, local)</TT></h3><A NAME="getlocal"></A>
<P>
This function returns the name and the value of the local variable
with index <CODE>local</CODE> of the function at level <CODE>level</CODE> of the stack.
(The first parameter has index 1, and so on,
until the last active local variable.)
The function returns <B>nil</B> if there is no local
variable with the given index,
and raises an error when called with a <CODE>level</CODE> out of range.
(You can call <CODE>getstack</CODE> to check wheter the level is valid.)
<P>
<h3> <TT>setlocal (level, local, value)</TT></h3><A NAME="setlocal"></A>
<P>
This function assigns the value <CODE>value</CODE> to the local variable
with index <CODE>local</CODE> of the function at level <CODE>level</CODE> of the stack.
The function returns <B>nil</B> if there is no local
variable with the given index,
and raises an error when called with a <CODE>level</CODE> out of range.
<P>
<h3> <TT>setcallhook (hook)</TT></h3><A NAME="setcallhook"></A>
<P>
Sets the function <CODE>hook</CODE> as the call hook;
this hook will be called every time the interpreter starts and
exits the execution of a function.
The only argument to this hook is the event name (<CODE>"call"</CODE> or
<CODE>"return"</CODE>).
You can call <CODE>getstack</CODE> with level 2 to get more information about
the function being called or returning
(level 0 is the <CODE>getstack</CODE> function,
and level 1 is the hook function).
<P>
When called without arguments,
this function turns off call hooks.
<P>
<h3> <TT>setlinehook (hook)</TT></h3><A NAME="setlinehook"></A>
<P>
Sets the function <CODE>hook</CODE> as the line hook;
this hook will be called every time the interpreter changes
the line of code it is executing.
The only argument to the hook is the line number the interpreter
is about to execute.
This hook is called only if the active function
has been compiled with debug information&nbsp;(see Section&nbsp;<A HREF="#pragma">4.9</A>).
<P>
When called without arguments,
this function turns off line hooks.
<P>
<P>
<A NAME="lua-sa"></A>
<!-- ====================================================================== -->
<HR>
<A NAME="8."></A>
<H1>8 - Lua Stand-alone</H1> 
<P>
Although Lua has been designed as an extension language,
the language is frequently used as a stand-alone interpreter.
An implementation of such an interpreter,
called simply <CODE>lua</CODE>,
is provided with the standard distribution.
This program can be called with any sequence of the following arguments:
<DL>
<DT><B><TT>-</TT></B><DD> executes <CODE>stdin</CODE> as a file;
<DT><B><TT>-d</TT></B><DD> turns on debug information;
<DT><B><TT>-e stat</TT></B><DD> executes string <CODE>stat</CODE>;
<DT><B><TT>-f filename</TT></B><DD> executes file <CODE>filename</CODE> with the
remaining arguments in table <CODE>arg</CODE>;
<DT><B><TT>-i</TT></B><DD> enters interactive mode with prompt;
<DT><B><TT>-q</TT></B><DD> enters interactive mode without prompt;
<DT><B><TT>-v</TT></B><DD> prints version information;
<DT><B><TT>var=value</TT></B><DD> sets global <CODE>var</CODE> to string <CODE>"value"</CODE>;
<DT><B><TT>filename</TT></B><DD> executes file <CODE>filename</CODE>.
</DL>
When called without arguments,
Lua behaves as <CODE>lua -v -i</CODE> when <CODE>stdin</CODE> is a terminal,
and as <CODE>lua -</CODE> otherwise.
<P>
All arguments are handled in order.
For instance, an invocation like
<PRE>
$ lua -i a=test prog.lua
</PRE>
will first interact with the user until an <CODE>EOF</CODE>,
then will set <CODE>a</CODE> to <CODE>"test"</CODE>,
and finally will run the file <CODE>prog.lua</CODE>.
<P>
When the option <TT>-f filename</TT> is used,
all following arguments from the command line
are passed to the Lua program in a table called <CODE>arg</CODE>.
The field <CODE>n</CODE> gets the index of the last argument,
and the field 0 gets the <TT>filename</TT>.
For instance, in the call
<PRE>
$ lua a.lua -f b.lua t1 t3
</PRE>
the interpreter first runs the file <TT>a.lua</TT>,
then creates a table <TT>arg</TT>,
<PRE>
  arg = {"t1", "t3";  n = 2, [0] = "b.lua"}
</PRE>
and then runs the file <TT>b.lua</TT>.
<P>
In interactive mode,
a multi-line statement can be written finishing intermediate
lines with a backslash (<CODE>\</CODE>).
If the global variable <CODE>_PROMPT</CODE> is defined as a string,
its value is used as the prompt. <A NAME="_PROMPT">_PROMPT</A>
Therefore, the prompt can be changed like below:
<PRE>
$ lua _PROMPT='myprompt&gt; ' -i
</PRE>
<P>
In Unix systems, Lua scripts can be made into executable programs
by using the <CODE>#!</CODE> form,
as in <CODE>#!/usr/local/bin/lua</CODE>,
or <CODE>#!/usr/local/bin/lua -f</CODE> to get other arguments.
<P>
<P>
<HR>
<A NAME="Acknowledgments"></A>
<h1>Acknowledgments</h1>
<P>
The authors would like to thank CENPES/PETROBRAS which,
jointly with TeCGraf, used extensively early versions of
this system and gave valuable comments.
The authors would also like to thank Carlos Henrique Levy,
who found the name of the game.
Lua means <EM>moon</EM> in Portuguese.
<P>
<P>
<P>
<P>
<HR>
<A NAME="Incompatibilities"></A>
<h1>Incompatibilities with Previous Versions</h1>
<P>
Although great care has been taken to avoid incompatibilities with
the previous public versions of Lua,
some differences had to be introduced.
Here is a list of all these incompatibilities.
<P>
<h2>Incompatibilities with <A NAME="version 3.2</h2>">version 3.2</h2></A>
<UL>
<P>
<LI>Old pre-compiled code is obsolete, and must be re-compiled.
<P>
</UL>
<P>
<P>
<P>
<P>

<HR>
<SMALL>
Last update:
Mon Apr 24 18:28:03 EST 2000
by <A HREF="http://www.tecgraf.puc-rio.br/~lhf/">lhf</A>.
</SMALL>

</BODY>
</HTML>
